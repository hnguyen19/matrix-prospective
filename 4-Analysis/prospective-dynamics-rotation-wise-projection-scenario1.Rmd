---
output:
    bookdown::word_document2:
      toc: false
      fig_caption: yes
    reference_docx: style_template.docx
---


```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(purrr) # for map2()
library(pracma)
library(popbio)
library(tidyverse)
library(magrittr) 
```

```{r periodic-matrices-phases-mean-and-var, include=FALSE}
## Pre-planting tillage 
mean_spring_tillage <-  readRDS("../2-Data/Clean/mean-pre-planting-tillage.RData")

var_spring_tillage <-  readRDS("../2-Data/Clean/var-pre-planting-tillage.RData")

## Emergence 
mean_emergence_scenario1 <- readRDS("../2-Data/Clean/mean-emergence-prop-scenario1.RData")

var_emergence_scenario1 <- readRDS("../2-Data/Clean/var-emergence-prop-scenario1.RData")

## Seed survival and plant survival 
#### seed survival 

mean_summer_seed_survival_scenario1  <- readRDS("../2-Data/Clean/mean-summer-seed-survival-scenario1.RData")

var_summer_seed_survival_scenario1  <- readRDS("../2-Data/Clean/var-summer-seed-survival-scenario1.RData")

#### plant survival: literature data
#female_survival <- readRDS("../2-Data/Clean/female-survival-rate-cohort-equal.RData")

mean_female_survival <- readRDS("../2-Data/Clean/mean-summer-seedling-survival-scenario2.RData")

var_female_survival <- readRDS("../2-Data/Clean/var-summer-seedling-survival-scenario2.RData")

#### combine seed and plant survivals into one matrix with element-wise multiplication: this is not computing, but arranging using 1's as placeholders 
mean_summer_survival_scenario1 <- purrr::map2(mean_summer_seed_survival_scenario1 , mean_female_survival, `*`)

var_summer_survival_scenario1 <- purrr::map2(var_summer_seed_survival_scenario1 , var_female_survival, `*`)

## Fecundity: next chunk


## Post-harvest tillage
mean_post_harvest_tillage <- readRDS("../2-Data/Clean/mean-post-harvest-tillage.RData")

var_post_harvest_tillage <- readRDS("../2-Data/Clean/var-post-harvest-tillage.RData")

## Overwinter survival 
mean_overwinter_scenario1 <- readRDS("../2-Data/Clean/mean-winter-seed-survival-scenario1.RData")

var_overwinter_scenario1 <- readRDS("../2-Data/Clean/var-winter-seed-survival-scenario1.RData")
```


```{r phase-wise-projection-1, include=FALSE}
## Circle starts at spring tillage Fecundity scenario 1 - 2019 rates

mean_fecundity_2019 <- readRDS("../2-Data/Clean/mean-fecundity-19-cohort.RData")

var_fecundity_2019 <- readRDS("../2-Data/Clean/var-fecundity-19-cohort.RData")

scenario1_projection_by_matrix_id <- tibble::lst(mean_overwinter_scenario1,
                                                 mean_post_harvest_tillage,
                                                 mean_fecundity_2019,
                                                 mean_summer_survival_scenario1,
                                               mean_emergence_scenario1,
                                               mean_spring_tillage)
## name column and row 
scenario1_projection_by_matrix_id_named <- rapply(scenario1_projection_by_matrix_id, 
                                                  function(x) {dimnames(x) <- rep(list(c("seed_top",
                                                                                        "seed_bottom", 
                                                                                        "plant_cohort_1",
                                                                                        "plant_cohort_2",
                                                                                        "plant_cohort_3",
                                                                                        "plant_cohort_4",
                                                                                        "plant_cohort_5",
                                                                                        "plant_cohort_6")),2); x}, how="list")

# View(scenario1_projection_by_matrix_id_named )

## List all periodic matrices within the same crop ID together  
scenario1_projection_by_matrix_id_transpose <- purrr::transpose(scenario1_projection_by_matrix_id_named )

# multiply all the periodic matrices within a crop ID 

scenario1_phase_projection <- scenario1_projection_by_matrix_id_transpose  %>%
  map(., ~{Reduce( "%*%", .)}) 

# check 
#lapply(scenario1_projection_by_matrix_id_transpose, 
#       \(x) x[[1]] %*% x[[2]] %*% x[[3]] %*% x[[4]] %*% x[[5]] %*% x[[6]])

```

```{r rotation-group, include=FALSE}
# Phases are listed right to left, which is the opposite to their orders 
#2year, conventional
scenario1_rotation_wise_2yr_conv <- scenario1_phase_projection[c("S2_conv", "C2_conv")]

#2year, low
scenario1_rotation_wise_2yr_low <- scenario1_phase_projection[c("S2_low","C2_low")]
#3-year, conventional
scenario1_rotation_wise_3yr_conv <- scenario1_phase_projection[c("O3_conv", "S3_conv", "C3_conv")]
#View(scenario1_rotation_wise_3yr_conv)

#3-year, low
scenario1_rotation_wise_3yr_low <- scenario1_phase_projection[c("O3_low", "S3_low", "C3_low")]

scenario1_rotation_wise_4yr_conv <- scenario1_phase_projection[c("A4_conv", "O4_conv", "S4_conv", "C4_conv")]

#4-year, low
scenario1_rotation_wise_4yr_low <- scenario1_phase_projection[c("A4_low", "O4_low", "S4_low", "C4_low")]


scenario1_rotation_group <- tibble::lst(scenario1_rotation_wise_2yr_conv,
                                     scenario1_rotation_wise_2yr_low,
                                     scenario1_rotation_wise_3yr_conv,
                                     scenario1_rotation_wise_3yr_low,
                                     scenario1_rotation_wise_4yr_conv,
                                     scenario1_rotation_wise_4yr_low)

scenario1_rotation_wise_projection <- scenario1_rotation_group %>%
  map(., ~{Reduce( "%*%", .)}) 

scenario1_rotation_wise_eigen <- scenario1_rotation_wise_projection %>%
  map(., ~{eigen.analysis(.)}) 

```


```{r scenario1-rotation-lambda, echo=FALSE}
scenario1_rotation_wise_lambda <- scenario1_rotation_wise_eigen %>%
  map(., ~{head(.,1)}) 

# make a df to admend to the next chunk's df 

scenario1_rotation_wise_lambda_df <- scenario1_rotation_wise_lambda %>%
   plyr::ldply(., data.frame)
```

Using 2019 fecundity rates, waterhemp populations in all crop identity is decreasing in all rotation, fastest in the 3-year rotation (Figures \@ref(fig:scenario1-lambda-annualized)). 
```{r scenario1-lambda-annualized-df, echo=FALSE}
scenario1_annualized_lambda_2yr <- rapply(scenario1_rotation_wise_lambda[1:2],
                                             function(x){nthroot(x,2)}, how = "list")    

scenario1_annualized_lambda_3yr <- rapply(scenario1_rotation_wise_lambda[3:4],
                                             function(x){nthroot(x,3)}, how = "list")

scenario1_annualized_lambda_4yr <- rapply(scenario1_rotation_wise_lambda[5:6],
                                             function(x){nthroot(x,4)}, how = "list")
   
scenario1_annualized_lambda_df <- tibble::lst(scenario1_annualized_lambda_2yr,
                                   scenario1_annualized_lambda_3yr,
                                   scenario1_annualized_lambda_4yr) %>%
   plyr::ldply(., data.frame) %>% 
  rename(conv = "lambda1", low = "lambda1.1")

scenario1_annualized_lambda_df_long <- scenario1_annualized_lambda_df %>%
  pivot_longer(!.id, names_to = "Corn_weed_management", values_to = "annualized_lambda") 

# View(scenario1_annualized_lambda_df_long)

## add the rotation-wise lambdas to the annualized lambdas 
scenario1_annualized_lambda_df_long$rot_wise_lambda <-  scenario1_rotation_wise_lambda_df$lambda1


```




```{r functions, include=FALSE}
# https://stackoverflow.com/questions/15795318/efficient-way-to-create-a-circulant-matrix-in-r

circ<-function(x) { 
    n<-length(x)
    matrix(x[matrix(1:n,n+1,n+1,byrow=T)[c(1,n:2),1:n]],n,n)
}
```

```{r circ-2yr-arrange}
### conventional 

# pick all phases in the 2yr conventional treatment and arrange in backward order, i.e., first subannual matrix in the first crop phase at the right-most (or bottom) position of the list
all_periods_2yr_conv <- scenario1_projection_by_matrix_id_transpose[c("S2_conv", "C2_conv")]
#View(all_periods_2yr_conv)

# remove the phase bounded structure in a chain, making a chain of 12 subannual matrices for the 2-year rotation
all_periods_2yr_conv_chain <- unlist(all_periods_2yr_conv, recursive = FALSE)

# make a reference grid, based on a chain starting at the spring_tillage matrix
ref_2yr_conv <- names(all_periods_2yr_conv_chain)

# create circular rotation of the first subannual matrix in each chain
circ_2yr_conv <- circ(ref_2yr_conv)

full_circ_2yr_conv <- purrr::map(1:12,~all_periods_2yr_conv_chain[circ_2yr_conv[.x,]])
# name the nested list by the last element in each nested list
# the last element in each nested list appear in the same order as circ_2yr_conv[,12]

names(full_circ_2yr_conv) <- paste0(circ_2yr_conv[,12],"_contribution") 

# check if nested lists names matches their last elements' names: YES
# View( full_circ_2yr_conv) check

# remove the last subannual matrix from the chain in full_circ_2yr_conv
until_circ_2yr_conv <- full_circ_2yr_conv  %>%
  map(., ~{head(.,11)})
# until_circ_2yr_conv contains 12 chains of 11 matrices each. In term of contribution to changes in lambda, each chain starts at the subannual matrix following the matrix of interest. The `until` and `though` designation is detailed in Caswell and Trevisan 1994. 
### low

# pick all phases in the 2yr conventional treatment
all_periods_2yr_low <- scenario1_projection_by_matrix_id_transpose[c("S2_low", "C2_low")]
#View(all_periods_2yr_conv)

# rearrange the phases in a chain
all_periods_2yr_low_chain <- unlist(all_periods_2yr_low, recursive = FALSE)

# make a reference grid 
ref_2yr_low <- names(all_periods_2yr_low_chain)

circ_2yr_low <- circ(ref_2yr_low)

full_circ_2yr_low <- purrr::map(1:12,~all_periods_2yr_low_chain[circ_2yr_low[.x,]])
# name the nested list by the last element in each nested list
# the last element in each nested list appear in the same order as circ_2yr_low[,12]

names(full_circ_2yr_low) <- paste0(circ_2yr_low[,12],"_contribution") 

# check if nested lists names matches their last elements' names: YES
# View( full_circ_2yr_low): each chain's product is identified by the right-most matrix 

# remove the last subannual matrix from the chain in full_circ_2yr_low
until_circ_2yr_low <- full_circ_2yr_low %>%
  map(., ~{head(.,11)})
```

In all LTRE procedures presented here, the conventional corn weed management treatment is the reference treatment and low herbicide the treatment of interest. Following @caswellSensitivityAnalysisPeriodic1994's notions:   

The sensitivity of $\lambda$ to each element of each sub-annual periodic matrix is calculated with  

$$
S_{B(h)} = {(B_{(h-1)}...B_{(1)}...B_{(h+1)})}^TS_{A(h)} = D^T S_{A(h)} \,\,\,(1)
$$
where,  
$B_{(h)}$ is the periodic projection matrix for sub-annual period h; h = {1,...,6},  
$D^T$ is the transpose of the matrix product of all the $B_{(h)}$, and   
$S_{A(h)}$ is the sensitivity of $\lambda$ to each element of $A^*_{(h)}$ (the average annual projection matrix between the reference treatment and the treatment of interest)  

The elasticities of $\lambda$ to each element of a sub-annual projection matrix is calculated with  
$$
E_{B(h)} = \frac{b_{ijk}}{\lambda} S_{B(h)} \,\,\,(2)
$$
where,  

$b_{ijk}$ is the entry at row i column j of matrix $B_{(h)}$, and other elements as defined in Equation (1).  

```{r LTRE-2yr}
## In all LTRE procedures, the conventional treatment is the reference matrix and low the treatment of interest

# left matrix multiplication of all chains (as defined by starting point, aka the right-most matrix of the chain) THROUGH the right-most matrix --> matrix A's

# The product of each list in the full_circ_2yr_xx is A(hk),
# A(hk) is the product of all sub-annual period starting at phase k, period h
A2_conv_contribution <- full_circ_2yr_conv %>%  
  map(., ~{Reduce( "%*%", .)}) 

A2_low_contribution <- full_circ_2yr_low %>% 
  map(., ~{Reduce( "%*%", .)}) 

A2_contribution <- lst(A2_conv_contribution, A2_low_contribution)

# calculate the A* matrix, average of the two products representing conventional and low corn weed management treatments 

A2_avg_contribution <- lapply(Reduce(\(...)Map('+', ...), A2_contribution), '/', length(A2_contribution))

# Matrix S_A(h)'s: sensitivity of lambda to each element of A(h), i.e. a(ijh), using matrix A*
A2_avg_sens <- A2_avg_contribution %>%
  map(., ~{sensitivity(.)})

# Matrix D: the product of all sub-annual matrices in backward order, until the B(h) matrix appear. 
# other words: left matrix multiplication of all chains (as defined by starting point, B(h), UNTIL the B(h) appear, the chain that makes up D is one matrix fewer than one that makes S

D2_conv_contribution <- until_circ_2yr_conv %>% 
  map(., ~{Reduce( "%*%", .)}) 

D2_low_contribution <- until_circ_2yr_low %>% 
  map(., ~{Reduce( "%*%", .)}) 

D2_contribution <- lst(D2_conv_contribution, D2_low_contribution)

### Do I really need D_avg? ### Yes

D2_avg_contribution <- lapply(Reduce(\(...)Map('+', ...), D2_contribution), '/', length(D2_contribution))

D2_avg_contribution_transposed <- D2_avg_contribution %>%
  map(., ~{t(.)})

# Matrix S_B(h):  sensitivity of lambda to changes in each element of the subannual matrix B(h)  
S_B_contribution_2yr <- purrr::map2(D2_avg_contribution_transposed, A2_avg_sens, `%*%`)

# remove "conv" in all names, conv was picked up from D2_conv_contribution because it was listed first in D2_contribution. 

## pick out the names
contribution_2yr_raw_names <- names( S_B_contribution_2yr)

## remove "conv" in all names
contribution_2yr_names <- gsub('conv.', '', contribution_2yr_raw_names)
## put the names back
names(S_B_contribution_2yr) <- contribution_2yr_names
```

In the corn phase of the 2-year rotation, the mobility of seeds at the bottom stratum to seedling cohort 2 was the highest contributor to changes in the population growth ($\lambda$); to the seedling cohorts 1, 3 and 4 were immediate contributors to changes in the population growth. The same pattern was observed for the top-stratum seeds in the corn phase of the 2-year rotation, but their contribution to changes in $\lambda$ were lower than those of the bottom-stratum seeds. 

In the soybean phase of the 2-year rotation, emergence minimally contributed to changes in population growth. 

*need a table, as graphs will be too many*


In 2019, as $\lambda$'s were under 1 for all treatments, fecundity did not contribute substantially to $\lambda$ changes. 




```{r elasticity-2yr}
# lambda atscenario1_annualized_lambda_df_long$annualized_lambd
lambda_2yr_conv <-scenario1_annualized_lambda_df_long$annualized_lambda[1]

lambda_2yr_low <-scenario1_annualized_lambda_df_long$annualized_lambda[2]
# Elasticity contribution left: check if all_periods_2yr_conv_chain is the appropriate element 
# The right-most matrix of all_periods_2yr_conv_chain is C2_spring_tillage
# why is the order of "all_periods_2yr_conv_chain" and "sens_contribution_2yr" opposite?

# Elasticity contribution left component: b_hij_2/lambda, or _3, _4 in the later chunks 
b_hij_2_over_lambda_conv <-  all_periods_2yr_conv_chain %>%
  map(., ~{./lambda_2yr_conv})

b_hij_2_over_lambda_low <-  all_periods_2yr_low_chain %>%
  map(., ~{./lambda_2yr_low})

# Elasticity contribution right component: S_B's 

# Multiply the left and right components 
E_B_contribution_2yr_conv <- Map(\(x, y) Reduce(`%*%`, list(x, y)), b_hij_2_over_lambda_conv, S_B_contribution_2yr)

## pick out the names
E_B_contribution_2yr_conv_raw_names <- names(E_B_contribution_2yr_conv )

## rename "means" with "E_B" in list names, for identification

E_B_contribution_2yr_conv_names <- gsub('mean', 'E_B', E_B_contribution_2yr_conv_raw_names )
## put the names back
names(E_B_contribution_2yr_conv ) <- E_B_contribution_2yr_conv_names 

E_B_contribution_2yr_low <- Map(\(x, y) Reduce(`%*%`, list(x, y)), b_hij_2_over_lambda_low, S_B_contribution_2yr)

## pick out the names
E_B_contribution_2yr_low_raw_names <- names(E_B_contribution_2yr_low)

## rename "means" with "E_B" in list names, for identification

E_B_contribution_2yr_low_names <- gsub('mean', 'E_B', E_B_contribution_2yr_low_raw_names )
## put the names back
names(E_B_contribution_2yr_low ) <- E_B_contribution_2yr_low_names 

```



```{r circ-3yr-arrange}
### conventional 

# pick all phases in the 3yr conventional treatment
all_periods_3yr_conv <- scenario1_projection_by_matrix_id_transpose[c("O3_conv", "S3_conv", "C3_conv")]
#View(all_periods_3yr_conv)

# rearrange the phases in a chain
all_periods_3yr_conv_chain <- unlist(all_periods_3yr_conv, recursive = FALSE)

# make a reference grid 
ref_3yr_conv <- names(all_periods_3yr_conv_chain)

circ_3yr_conv <- circ(ref_3yr_conv)

full_circ_3yr_conv <- purrr::map(1:18,~all_periods_3yr_conv_chain[circ_3yr_conv[.x,]])
# name the nested list by the last element in each nested list
# the last element in each nested list appear in the same order as circ_3yr_conv[,12]

names(full_circ_3yr_conv) <- paste0(circ_3yr_conv[,18],"_contribution") 

# check if nested lists names matches their last elements' names: YES
# View( full_circ_2yr_conv) check

# remove the last subannual matrix from the chain in full_circ_3yr_conv
until_circ_3yr_conv <- full_circ_3yr_conv  %>%
  map(., ~{head(.,11)})

### low

# pick all phases in the 3yr low treatment
all_periods_3yr_low <- scenario1_projection_by_matrix_id_transpose[c("O3_low", "S3_low", "C3_low")]
#View(all_periods_2yr_conv)

# rearrange the phases in a chain
all_periods_3yr_low_chain <- unlist(all_periods_3yr_low, recursive = FALSE)

# make a reference grid 
ref_3yr_low <- names(all_periods_3yr_low_chain)

circ_3yr_low <- circ(ref_3yr_low)

full_circ_3yr_low <- purrr::map(1:18,~all_periods_3yr_low_chain[circ_3yr_low[.x,]])
# name the nested list by the last element in each nested list
# the last element in each nested list appear in the same order as circ_3yr_low[,12]

names(full_circ_3yr_low) <- paste0(circ_3yr_low[,18],"_contribution") 

# check if nested lists names matches their last elements' names: YES
# View( full_circ_3yr_low) 

# remove the last subannual matrix from the chain in full_circ_3yr_low
until_circ_3yr_low <- full_circ_3yr_low %>%
  map(., ~{head(.,11)})
```

```{r LTRE-3yr}
## In all LTRE procedures, the conventional treatment is the reference matrix and low the

# left matrix multiplication of all chains (as defined by starting point, aka the right-most matrix of the chain) THROUGH the right-most matrix --> matrix A's
A3_conv_contribution <- full_circ_3yr_conv %>% 
  map(., ~{Reduce( "%*%", .)}) 

A3_low_contribution <- full_circ_3yr_low %>% 
  map(., ~{Reduce( "%*%", .)}) 

A3_contribution <- lst(A3_conv_contribution, A3_low_contribution)

A3_avg_contribution <- lapply(Reduce(\(...)Map('+', ...), A3_contribution), '/', length(A3_contribution))

# Sensitivities with regards to the right-most matrix --> matrix S_a's
A3_avg_sens <- A3_avg_contribution %>%
  map(., ~{sensitivity(.)})

# left matrix multiplication of all chains (as defined by starting point, aka the right-most matrix of the chain) UNTIL the right-most matrix appear --> matrix D's

D3_conv_contribution <- until_circ_3yr_conv %>% 
  map(., ~{Reduce( "%*%", .)}) 

D3_low_contribution <- until_circ_3yr_low %>% 
  map(., ~{Reduce( "%*%", .)}) 

D3_contribution <- lst(D3_conv_contribution, D3_low_contribution)

D3_avg_contribution <- lapply(Reduce(\(...)Map('+', ...), D3_contribution), '/', length(D3_contribution))

S_B_contribution_3yr <- purrr::map2(D3_avg_contribution, A3_avg_sens, `%*%`)

# remove "conv" in all names
contribution_3yr_raw_names <- names(S_B_contribution_3yr )

contribution_3yr_names <- gsub('conv.', '', contribution_3yr_raw_names)

names(S_B_contribution_3yr) <- contribution_3yr_names
```


```{r elasticity-3yr}
# lambda at scenario1_rotation_wise_lambda 
lambda_3yr_conv <- scenario1_annualized_lambda_df_long$annualized_lambda[3]

lambda_3yr_low <- scenario1_annualized_lambda_df_long$annualized_lambda[4]


# Elasticity contribution left component: b_hij_3/lambda,
b_hij_3yr_over_lambda_conv <-  all_periods_3yr_conv_chain %>%
  map(., ~{./lambda_3yr_conv})

b_hij_3yr_over_lambda_low <-  all_periods_3yr_low_chain %>%
  map(., ~{./lambda_3yr_low})

# Elasticity contribution right component: S_B's 

# ## Calculate E_Bs: Multiply the left and right components 
E_B_contribution_3yr_conv <- Map(\(x, y) Reduce(`%*%`, list(x, y)), b_hij_3yr_over_lambda_conv, S_B_contribution_3yr)
## pick out the names
E_B_contribution_3yr_conv_raw_names <- names(E_B_contribution_3yr_conv )

## rename "means" with "E_B" in list names, for identification

E_B_contribution_3yr_conv_names <- gsub('mean', 'E_B', E_B_contribution_3yr_conv_raw_names )
## put the names back
names(E_B_contribution_3yr_conv ) <- E_B_contribution_3yr_conv_names 


## Calculate E_Bs
E_B_contribution_3yr_low <- Map(\(x, y) Reduce(`%*%`, list(x, y)), b_hij_3yr_over_lambda_low, S_B_contribution_3yr)

## pick out the names
E_B_contribution_3yr_low_raw_names <- names(E_B_contribution_3yr_low)

## rename "means" with "E_B" in list names, for identification

E_B_contribution_3yr_low_names <- gsub('mean', 'E_B', E_B_contribution_3yr_low_raw_names )
## put the names back
names(E_B_contribution_3yr_low ) <- E_B_contribution_3yr_low_names 
```



```{r circ-4yr-arrange}
### conventional 

# pick all phases in the 4yr conventional treatment
all_periods_4yr_conv <- scenario1_projection_by_matrix_id_transpose[c("A4_conv", "O4_conv", "S4_conv", "C4_conv")]
# View(all_periods_4yr_conv)

# rearrange the phases in a chain
all_periods_4yr_conv_chain <- unlist(all_periods_4yr_conv, recursive = FALSE)

# make a reference grid 
ref_4yr_conv <- names(all_periods_4yr_conv_chain)

circ_4yr_conv <- circ(ref_4yr_conv)

full_circ_4yr_conv <- purrr::map(1:24,~all_periods_4yr_conv_chain[circ_4yr_conv[.x,]])
# name the nested list by the last element in each nested list
# the last element in each nested list appear in the same order as circ_4yr_conv[,12]

names(full_circ_4yr_conv) <- paste0(circ_4yr_conv[,24],"_contribution") 

# check if nested lists names matches their last elements' names: YES
# View( full_circ_4yr_conv) check

# remove the last subannual matrix from the chain in full_circ_3yr_conv
until_circ_4yr_conv <- full_circ_4yr_conv  %>%
  map(., ~{head(.,11)})

### low

# pick all phases in the 3yr low treatment
all_periods_4yr_low <- scenario1_projection_by_matrix_id_transpose[c("A4_low", "O4_low", "S4_low", "C4_low")]
#View(all_periods_4yr_conv)

# rearrange the phases in a chain
all_periods_4yr_low_chain <- unlist(all_periods_4yr_low, recursive = FALSE)

# make a reference grid 
ref_4yr_low <- names(all_periods_4yr_low_chain)

circ_4yr_low <- circ(ref_4yr_low)

full_circ_4yr_low <- purrr::map(1:24,~all_periods_4yr_low_chain[circ_4yr_low[.x,]])
# name the nested list by the last element in each nested list
# the last element in each nested list appear in the same order as circ_4yr_low[,12]

names(full_circ_4yr_low) <- paste0(circ_4yr_low[,24],"_contribution") 

# check if nested lists names matches their last elements' names: YES
# View( full_circ_4yr_low) 

# remove the last subannual matrix from the chain in full_circ_4yr_low
until_circ_4yr_low <- full_circ_4yr_low %>%
  map(., ~{head(.,11)})
```


```{r LTRE-4yr}
## In all LTRE procedures, the conventional treatment is the reference matrix and low the

# left matrix multiplication of all chains (as defined by starting point, aka the right-most matrix of the chain) THROUGH the right-most matrix --> matrix A's
A4_conv_contribution <- full_circ_4yr_conv %>% 
  map(., ~{Reduce( "%*%", .)}) 

A4_low_contribution <- full_circ_4yr_low %>% 
  map(., ~{Reduce( "%*%", .)}) 

A4_contribution <- lst(A4_conv_contribution, A4_low_contribution)

A4_avg_contribution <- lapply(Reduce(\(...)Map('+', ...), A4_contribution), '/', length(A4_contribution))

# Sensitivities with regards to the right-most matrix --> matrix S_A's
A4_avg_sens <- A4_avg_contribution %>%
  map(., ~{sensitivity(.)})

# left matrix multiplication of all chains (as defined by starting point, aka the right-most matrix of the chain) UNTIL the right-most matrix appear --> matrix D's

D4_conv_contribution <- until_circ_4yr_conv %>% 
  map(., ~{Reduce( "%*%", .)}) 

D4_low_contribution <- until_circ_4yr_low %>% 
  map(., ~{Reduce( "%*%", .)}) 

D4_contribution <- lst(D4_conv_contribution, D4_low_contribution)

D4_avg_contribution <- lapply(Reduce(\(...)Map('+', ...), D4_contribution), '/', length(D4_contribution))

D4_avg_contribution_transposed <- D4_avg_contribution %>% map(.,~{t(.)})

## contribution of each sub-annual matrix to lambda's sensitivities, matrix S_B's                                     
S_B_contribution_4yr <- purrr::map2(D4_avg_contribution_transposed, A4_avg_sens, `%*%`)
# remove "conv" in all names
S_B_contribution_4yr_raw_names <- names( S_B_contribution_4yr )

S_B_contribution_4yr_names <- gsub('conv.', '', S_B_contribution_4yr_raw_names)

names(S_B_contribution_4yr) <- S_B_contribution_4yr_names
```


```{r elasticity-4yr}
## calculate elasticity, see p. 121

## NEED NEW NAMES FOR ALL THE LIST
# lambda at scenario1_rotation_wise_lambda 
lambda_4yr_conv <-scenario1_annualized_lambda_df_long$annualized_lambda[5]

lambda_4yr_low <-scenario1_annualized_lambda_df_long$annualized_lambda[6]
# Elasticity contribution left: check if all_periods_4yr_conv_chain is the appropriate element 
# The right-most matrix of all_periods_4yr_conv_chain is C4_spring_tillage
# why is the order of "all_periods_4yr_conv_chain" and "sens_contribution_4yr" opposite?


b_hij_4yr_over_lambda_conv_left <-  all_periods_4yr_conv_chain %>%
  map(., ~{./lambda_4yr_conv})

b_hij_4yr_over_lambda_low_left <-  all_periods_4yr_low_chain %>%
  map(., ~{./lambda_4yr_low})

# Elasticity contribution right component: S_B's sens_contribution_4yr

# Elasticity
E_B_contribution_4yr_conv  <- Map(\(x, y) Reduce(`%*%`, list(x, y)),
                                  b_hij_4yr_over_lambda_conv_left ,
                                  S_B_contribution_4yr)
## pick out the names
E_B_contribution_4yr_conv_raw_names <- names(E_B_contribution_4yr_conv )

## rename "means" with "E_B" in list names, for identification

E_B_contribution_4yr_conv_names <- gsub('mean', 'E_B', E_B_contribution_4yr_conv_raw_names )
## put the names back
names(E_B_contribution_4yr_conv ) <- E_B_contribution_4yr_conv_names 


E_B_contribution_4yr_low  <- Map(\(x, y) Reduce(`%*%`, list(x, y)),
                                 b_hij_4yr_over_lambda_low_left,
                                 S_B_contribution_4yr)

## pick out the names
E_B_contribution_4yr_low_raw_names <- names(E_B_contribution_4yr_low)

## rename "means" with "E_B" in list names, for identification

E_B_contribution_4yr_low_names <- gsub('mean', 'E_B', E_B_contribution_4yr_low_raw_names )
## put the names back
names(E_B_contribution_4yr_low ) <- E_B_contribution_4yr_low_names 
```


```{r var-list, echo=FALSE}
# <https://en.wikipedia.org/wiki/Taylor_expansions_for_the_moments_of_functions_of_random_variables> .

## Need variance separated for each parameters in the summer survival period 
## issue: things happening at the same period need to be in one matrix 
## work-around: comment on period-based changes instead of parameter-based changes 


## Combine all variance lists into one grand list, similar to the means list

## Variance list needed for each rotation, but in the opposite order as in the mean list, to accommodate the order of the S_B list

var_scenario1_projection_by_matrix_id <- tibble::lst(var_spring_tillage,
                                                     var_emergence_scenario1,
                                                      var_summer_survival_scenario1,
                                                       var_fecundity_2019,
                                                        var_post_harvest_tillage,
                                                     var_overwinter_scenario1)
# A list of 12 bested list
var_scenario1_projection_by_matrix_id_named <- rapply(var_scenario1_projection_by_matrix_id , 
                                                  function(x) {dimnames(x) <- rep(list(c("seed_top",
                                                                                        "seed_bottom", 
                                                                                        "plant_cohort_1",
                                                                                        "plant_cohort_2",
                                                                                        "plant_cohort_3",
                                                                                        "plant_cohort_4",
                                                                                        "plant_cohort_5",
                                                                                        "plant_cohort_6")),2); x}, how="list")

# Transpose the var list to rearrange will create a nested list of 18 lists of 12 matrices each
var_scenario1_projection_transpose <- purrr::transpose(var_scenario1_projection_by_matrix_id_named)

# Separate variance by rotation x corn weed management 
var_scenario1_projection_2yr_conv <- var_scenario1_projection_transpose[c("C2_conv","S2_conv")]
var_scenario1_projection_2yr_conv_unlist <- unlist(var_scenario1_projection_2yr_conv, recursive = FALSE)

var_scenario1_projection_2yr_low <- var_scenario1_projection_transpose[c("C2_low","S2_low")]
var_scenario1_projection_2yr_low_unlist <- unlist(var_scenario1_projection_2yr_low, recursive = FALSE)

var_scenario1_projection_3yr_conv <- var_scenario1_projection_transpose[c("C3_conv","S3_conv", "O3_conv")]
var_scenario1_projection_3yr_conv_unlist <- unlist(var_scenario1_projection_3yr_conv, recursive = FALSE)

var_scenario1_projection_3yr_low <- var_scenario1_projection_transpose[c("C3_low","S3_low", "O3_low")]
var_scenario1_projection_3yr_low_unlist <- unlist(var_scenario1_projection_3yr_low, recursive = FALSE)

var_scenario1_projection_4yr_conv <- var_scenario1_projection_transpose[c("C4_conv","S4_conv", "O4_conv", "A4_conv")]
var_scenario1_projection_4yr_conv_unlist <- unlist(var_scenario1_projection_4yr_conv, recursive = FALSE)

var_scenario1_projection_4yr_low <- var_scenario1_projection_transpose[c("C4_low","S4_low", "O4_low", "A4_low")]
var_scenario1_projection_4yr_low_unlist <- unlist(var_scenario1_projection_4yr_low, recursive = FALSE)
# recombine variance using the same order as S_B

var_scenario1_projection_conv <- tibble::lst(var_scenario1_projection_2yr_conv_unlist,
                                             var_scenario1_projection_3yr_conv_unlist,
                                             var_scenario1_projection_4yr_conv_unlist)

#View(var_scenario1_projection_conv)



var_scenario1_projection_low <- tibble::lst(var_scenario1_projection_2yr_low_unlist,
                                             var_scenario1_projection_3yr_low_unlist,
                                             var_scenario1_projection_4yr_low_unlist)

#View(var_scenario1_projection_low)
```

```{r S-B-recombine, echo=FALSE}
## Gather S_B contribution lists by sub-annual matrices: all the spring tillage matrices in 6 cropping systems together, all the emergence matrices together, ...

S_B_contribution_recombined <- tibble::lst(S_B_contribution_2yr, 
                                           S_B_contribution_3yr,
                                           S_B_contribution_4yr)


## Trim each matrix in the recombined S_B contribution list to the needed n row x 1 column
#https://stackoverflow.com/questions/72326431/extract-the-same-column-from-all-matrices-in-a-nested-list/72326729#72326729

S_B_contribution_recombined_first_col <- rapply(S_B_contribution_recombined, \(x) x[, 1, drop=FALSE], how='list')

## Transpose the trimmed S_B list

S_B_contribution_recombined_first_col_transpose <- rapply(S_B_contribution_recombined_first_col, \(x) t(x), how='list')
```

```{r var-rot-lambda, echo=FALSE}
var_lambda_conv_elements  <- Map(\(x, y, z) Reduce(`%*%`,
                      list(x, y, z)),
    unlist(S_B_contribution_recombined_first_col_transpose, recursive = F),
    unlist(var_scenario1_projection_conv, recursive = F),
    unlist(S_B_contribution_recombined_first_col, recursive = F))

var_lambda_conv_2yr <- sum(unlist(var_lambda_conv_elements[1:12]))
var_lambda_conv_3yr <- sum(unlist(var_lambda_conv_elements[13:30]))
var_lambda_conv_4yr <- sum(unlist(var_lambda_conv_elements[31:54]))

var_lambda_low_elements  <- Map(\(x, y, z) Reduce(`%*%`,
                      list(x, y, z)),
    unlist(S_B_contribution_recombined_first_col_transpose, recursive = F),
    unlist(var_scenario1_projection_low, recursive = F),
    unlist(S_B_contribution_recombined_first_col, recursive = F))



var_lambda_low_2yr <- sum(unlist(var_lambda_low_elements[1:12]))
var_lambda_low_3yr <- sum(unlist(var_lambda_low_elements[13:30]))
var_lambda_low_4yr <- sum(unlist(var_lambda_low_elements[31:54]))
```

In all cropping systems, the two largest component of rotational $\lambda$ variance were from summer survival and fecundity. *Detailed contribution of variance in each sub-annual matrices to the variance of $\lambda$ are provided in the Appendix.* This observation is expected because populations were declining in all cropping systems in this scenario.  

```{r var-annualized-lambda}
# combine all variance into a data frame and calculate annualized lambda's var

scenario1_annualized_lambda_df_long$Rotation_var_lambda <- c(var_lambda_conv_2yr,
                                      var_lambda_low_2yr,
                                      var_lambda_conv_3yr,
                                      var_lambda_low_3yr,
                                      var_lambda_conv_4yr,
                                      var_lambda_low_4yr)

# add multiplier to the var table
scenario1_annualized_lambda_df_long$multiplier <- c(1/4, 1/4, 1/9, 1/9, 1/16, 1/16)



# how to explain negative variance components?


# combine lambda, var(lambda), and *variance contribution* and rename the data frame
scenario1_annualized_lambda_and_var <- scenario1_annualized_lambda_df_long %>%
  mutate(squared_annualized_lambda = annualized_lambda^2,
         var_annualized_lambda = multiplier * Rotation_var_lambda/squared_annualized_lambda) %>%
  select(.id, Corn_weed_management, annualized_lambda, var_annualized_lambda)


## subset all the lists
#View( scenario1_annualized_lambda_and_var)
#https://community.rstudio.com/t/subset-a-nested-list-to-get-all-the-lower-level-lists-with-the-same-characters-in-their-names/138320

var_lambda_conv_top_element <- var_lambda_conv_elements[str_detect(names(var_lambda_conv_elements), "summer")]

var_lambda_conv_second_elements <-  var_lambda_conv_elements[str_detect(names(var_lambda_conv_elements), "fecund")]

var_lambda_low_top_element <- var_lambda_low_elements[str_detect(names(var_lambda_low_elements), "summer")]

var_lambda_low_second_element <- var_lambda_low_elements[str_detect(names(var_lambda_low_elements), "fecund")]


```


 
```{r all-E-B, include=FALSE}
E_B_contribution <- tibble::lst(E_B_contribution_2yr_conv,
                                E_B_contribution_2yr_low,
                                E_B_contribution_3yr_conv,
                                E_B_contribution_3yr_low,
                                E_B_contribution_4yr_conv,
                                E_B_contribution_4yr_low )

#View(E_B_contribution  )
# Keep non-zeros only 
matrix_trim <- function(x) {
      m1 <- x == 0
      x[!(rowSums(m1)== ncol(m1)), 
      !(colSums(m1) == nrow(m1)),drop = FALSE]
}

E_B_contribution_trimmed  <- rapply(E_B_contribution,
                                                          \(x) matrix_trim(x),
                                                          how='list')


rapply(E_B_contribution_trimmed ,
                                                          \(x) round(x,3),
                                                          how='list')
```



```{r E-B-table}

E_B_table_raw <- expand.grid(Rotation = c("2-year","3-year", "4-year"),
                         Corn_weed_management = c("conventional", "low"),
                         Phase = c("corn", "soybean"))
E_B_table_3yr <- expand.grid(Rotation = "3-year",
                         Corn_weed_management = c("conventional", "low"),
                         Phase = c("oat/red clover"))
E_B_table_4yr <- expand.grid(Rotation = "4-year",
                         Corn_weed_management = c("conventional", "low"),
                         Phase = c("oat/alfalfa", "alfalfa"))

E_B_table <- rbind(E_B_table_raw, E_B_table_3yr, E_B_table_4yr)

## Arrange the E_B rows by Rotation
E_B_table_ordered <- E_B_table %>% arrange(Rotation)

## Fill in the most influential b_ijk values and indices following the orders in Rotation x Phase: print to fill 
E_B_table_ordered$`tau(spring)` = c("(2,2) 0.72", "(2,2) 0.76", "(2,2), 0.70", "(2,2) 0.73",
                                    "(2,2) 1.1", "(2,2) 1.1", "(2,2) 0.88", "(2,2) 0.88", "(2,2) 0.87", "(2,2) 0.87",
                                    "(2,2) 0.66", "(2,2) 0.48", "(2,2) 0.49", "(2,2) 0.36", "(1,2) and (2,2) 5.5", "(1,2) and (2,2) 4.0", "(2,2) 2.1", "(2,2) 1.6")

E_B_table_ordered$gamma = c("\U03B5_{1,1}")

E_B_table_ordered$`sigma(seed, summer)`

E_B_table_ordered$`sigma(seedling)`

E_B_table_ordered$`phi` = c("")

E_B_table_ordered$`tau(fall)` = c("(2,2) 0.51", "(2,2) 0.54", "(2,2), 0.39", "(2,2) 0.37",
                                    "(2,2) 0.55", "(2,2) 0.55", "(2,2) 0.60", "(2,2) 0.60", "(2,2) 0.80", "(2,2) 0.80",
                                    "(2,2) 0.37", "(2,2) 0.27", "(2,2) 0.29", "(2,2) 0.21", "(2,2) 2.05", "(2,2) 1.50", "(2,2) 0.54", "(2,2) 0.40")

E_B_table_ordered$`sigma(seed, winter)` = c("(2,2) 0.31", "(2,2) 0.32", "(2,2), 0.28", "(2,2) 0.29",
                                    "(2,2) 0.51", "(2,2) 0.51", "(2,2) 0.52", "(2,2) 0.52", "(2,2) 0.67", "(2,2) 0.68",
                                    "(2,2) 0.23", "(2,2) 0.17", "(1,2) 6.80", "(1,2) 4.90", "(2,1) 1.21" , "(2,1) 0.87", "(2,2) 0.20", "(2,2) 0.28")

```
