---
output:
    bookdown::word_document2:
      toc: false
      fig_caption: yes
    reference_docx: style_template.docx
---


```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(purrr) # for map2()
library(pracma)
library(popbio)
library(tidyverse)
```

```{r periodic-matrices-phase, include=FALSE}
## Pre-planting tillage 
spring_tillage <-  readRDS("../2-Data/Clean/pre-planting-tillage.RData")

## Emergence 
emergence_scenario1 <- readRDS("../2-Data/Clean/emergence-prop-scenario1.RData")

## Seed survival and plant survival 
#### seed survival 

summer_seed_survival_scenario1  <- readRDS("../2-Data/Clean/summer-seed-survival-scenario1.RData")

#### plant survival
#female_survival <- readRDS("../2-Data/Clean/female-survival-rate-cohort-equal.RData")

female_survival <- readRDS("../2-Data/Clean/summer-seedling-survival-scenario2.RData")
#### combine seed and plant survivals into one matrix with element-wise multiplication 
summer_survival_scenario1 <- purrr::map2(summer_seed_survival_scenario1 , female_survival, `*`)

## Post-harvest tillage
post_harvest_tillage <- readRDS("../2-Data/Clean/post-harvest-tillage.RData")

## Overwinter survival 
overwinter_scenario1 <- readRDS("../2-Data/Clean/winter-seed-survival-scenario1.RData")

```


```{r phase-wise-projection-1, include=FALSE}
## Circle starts at spring tillage Fecundity scenario 1 - 2019 rates

fecundity_2019 <- readRDS("../2-Data/Clean/fecundity-mean-19-cohort.RData")

scenario1_projection_by_matrix_id <- tibble::lst(overwinter_scenario1,
                                                 post_harvest_tillage,
                                                 fecundity_2019,
                                                 summer_survival_scenario1,
                                               emergence_scenario1,
                                               spring_tillage)

## List all periodic matrices within the same crop ID together  
scenario1_projection_by_matrix_id_transpose <- transpose(scenario1_projection_by_matrix_id )

# multiply all the periodic matrices within a crop ID 

scenario1_phase_projection <- scenario1_projection_by_matrix_id_transpose  %>%
  map(., ~{Reduce( "%*%", .)}) 

# check 
#lapply(scenario1_projection_by_matrix_id_transpose, 
#       \(x) x[[1]] %*% x[[2]] %*% x[[3]] %*% x[[4]] %*% x[[5]] %*% x[[6]])

```

```{r rotation-group, include=FALSE}
#2year, conventional
scenario1_rotation_wise_2yr_conv <- scenario1_phase_projection[c("S2_conv", "C2_conv")]

#2year, low
scenario1_rotation_wise_2yr_low <- scenario1_phase_projection[c("S2_low","C2_low")]
#3-year, conventional
scenario1_rotation_wise_3yr_conv <- scenario1_phase_projection[c("O3_conv", "S3_conv", "C3_conv")]
#View(scenario1_rotation_wise_3yr_conv)

#3-year, low
scenario1_rotation_wise_3yr_low <- scenario1_phase_projection[c("O3_low", "S3_low", "C3_low")]

scenario1_rotation_wise_4yr_conv <- scenario1_phase_projection[c("A4_conv", "O4_conv", "S4_conv", "C4_conv")]

#4-year, low
scenario1_rotation_wise_4yr_low <- scenario1_phase_projection[c("A4_low", "O4_low", "S4_low", "C4_low")]


scenario1_rotation_group <- tibble::lst(scenario1_rotation_wise_2yr_conv,
                                     scenario1_rotation_wise_2yr_low,
                                     scenario1_rotation_wise_3yr_conv,
                                     scenario1_rotation_wise_3yr_low,
                                     scenario1_rotation_wise_4yr_conv,
                                     scenario1_rotation_wise_4yr_low)

scenario1_rotation_wise_projection <- scenario1_rotation_group %>%
  map(., ~{Reduce( "%*%", .)}) 

scenario1_rotation_wise_eigen <- scenario1_rotation_wise_projection %>%
  map(., ~{eigen.analysis(.)}) 

```


```{r scenario1-rotation-lambda, echo=FALSE}
scenario1_rotation_wise_lambda <- scenario1_rotation_wise_eigen %>%
  map(., ~{head(.,1)})
```

Using 2019 fecundity rates, waterhemp populations in all crop identity is decreasing in all rotation, fastest in the 3-year rotation (Figures \@ref(fig:scenario1-lambda-annualized)). 
```{r scenario1-lambda-annualized, echo=FALSE, fig.cap= "Annualized waterhemp population growth rate using 2019 fecundity rate."}
scenario1_rotation_wise_lambda_2yr <- rapply(scenario1_rotation_wise_lambda[1:2],
                                             function(x){nthroot(x,2)}, how = "list")    

scenario1_rotation_wise_lambda_3yr <- rapply(scenario1_rotation_wise_lambda[3:4],
                                             function(x){nthroot(x,3)}, how = "list")

scenario1_rotation_wise_lambda_4yr <- rapply(scenario1_rotation_wise_lambda[5:6],
                                             function(x){nthroot(x,4)}, how = "list")
   
scenario1_lambda_df <- tibble::lst(scenario1_rotation_wise_lambda_2yr,
                                   scenario1_rotation_wise_lambda_3yr,
                                   scenario1_rotation_wise_lambda_4yr)%>%
   plyr::ldply(., data.frame) %>% 
  rename(conv = "lambda1", low = "lambda1.1")

scenario1_lambda_df_long <- scenario1_lambda_df %>%
  pivot_longer(!.id, names_to = "Corn_weed_management", values_to = "annualized_lambda") 
  
x_labs <- c("2-year", "3-year", "4-year")

ggplot(scenario1_lambda_df_long, aes(y = annualized_lambda, x = .id , fill = Corn_weed_management)) + 
  geom_bar(stat = "identity", position = "dodge") +
  ylab("Annualized population growth rate with 2019 fecundity") +
  xlab("Rotation") +
  scale_x_discrete(labels= x_labs) +
  theme_bw()
```



```{r functions, include=FALSE}
# https://stackoverflow.com/questions/15795318/efficient-way-to-create-a-circulant-matrix-in-r

circ<-function(x) { 
    n<-length(x)
    matrix(x[matrix(1:n,n+1,n+1,byrow=T)[c(1,n:2),1:n]],n,n)
}
```

```{r circ-2yr-arrange}
### conventional 

# pick all phases in the 2yr conventional treatment
all_periods_2yr_conv <- scenario1_projection_by_matrix_id_transpose[c("S2_conv", "C2_conv")]
#View(all_periods_2yr_conv)

# rearrange the phases in a chain
all_periods_2yr_conv_chain <- unlist(all_periods_2yr_conv, recursive = FALSE)

# make a reference grid 
ref_2yr_conv <- names(all_periods_2yr_conv_chain)

circ_2yr_conv <- circ(ref_2yr_conv)

full_circ_2yr_conv <- purrr::map(1:12,~all_periods_2yr_conv_chain[circ_2yr_conv[.x,]])
# name the nested list by the last element in each nested list
# the last element in each nested list appear in the same order as circ_2yr_conv[,12]

names(full_circ_2yr_conv) <- paste0(circ_2yr_conv[,12],"_contribution") 

# check if nested lists names matches their last elements' names: YES
# View( full_circ_2yr_conv) check

# remove the last subannual matrix from the chain in full_circ_2yr_conv
until_circ_2yr_conv <- full_circ_2yr_conv  %>%
  map(., ~{head(.,11)})

### low

# pick all phases in the 2yr conventional treatment
all_periods_2yr_low <- scenario1_projection_by_matrix_id_transpose[c("S2_low", "C2_low")]
#View(all_periods_2yr_conv)

# rearrange the phases in a chain
all_periods_2yr_low_chain <- unlist(all_periods_2yr_low, recursive = FALSE)

# make a reference grid 
ref_2yr_low <- names(all_periods_2yr_low_chain)

circ_2yr_low <- circ(ref_2yr_low)

full_circ_2yr_low <- purrr::map(1:12,~all_periods_2yr_low_chain[circ_2yr_low[.x,]])
# name the nested list by the last element in each nested list
# the last element in each nested list appear in the same order as circ_2yr_low[,12]

names(full_circ_2yr_low) <- paste0(circ_2yr_low[,12],"_contribution") 

# check if nested lists names matches their last elements' names: YES
# View( full_circ_2yr_low): each chain's product is identified by the right-most matrix 

# remove the last subannual matrix from the chain in full_circ_2yr_low
until_circ_2yr_low <- full_circ_2yr_low %>%
  map(., ~{head(.,11)})
```

```{r LTRE-2yr}
## In all LTRE procedures, the conventional treatment is the reference matrix and low the

# left matrix multiplication of all chains (as defined by starting point, aka the right-most matrix of the chain) THROUGH the right-most matrix --> matrix A's
A2_conv_contribution <- full_circ_2yr_conv %>%  
  map(., ~{Reduce( "%*%", .)}) 

A2_low_contribution <- full_circ_2yr_low %>% 
  map(., ~{Reduce( "%*%", .)}) 

A2_contribution <- lst(A2_conv_contribution, A2_low_contribution)

A2_avg_contribution <- lapply(Reduce(\(...)Map('+', ...), A2_contribution), '/', length(A2_contribution))

# Sensitivities with regards to the right-most matrix --> matrix S_a's
A2_avg_sens <- A2_avg_contribution %>%
  map(., ~{sensitivity(.)})

# left matrix multiplication of all chains (as defined by starting point, aka the right-most matrix of the chain) UNTIL the right-most matrix appear --> matrix D's

D2_conv_contribution <- until_circ_2yr_conv %>% 
  map(., ~{Reduce( "%*%", .)}) 

D2_low_contribution <- until_circ_2yr_low %>% 
  map(., ~{Reduce( "%*%", .)}) 

D2_contribution <- lst(D2_conv_contribution, D2_low_contribution)

D2_avg_contribution <- lapply(Reduce(\(...)Map('+', ...), D2_contribution), '/', length(D2_contribution))

#sensitivities with respect to the right-most matrix in each chain
contribution_2yr <- purrr::map2(D2_avg_contribution, A2_avg_sens, `%*%`)

# remove "conv" in all names
contribution_2yr_raw_names <- names( contribution_2yr )

contribution_2yr_names <- gsub('conv.', '', contribution_2yr_raw_names)

names(contribution_2yr) <- contribution_2yr_names
```

```{r circ-3yr-arrange}
### conventional 

# pick all phases in the 3yr conventional treatment
all_periods_3yr_conv <- scenario1_projection_by_matrix_id_transpose[c("O3_conv", "S3_conv", "C3_conv")]
#View(all_periods_3yr_conv)

# rearrange the phases in a chain
all_periods_3yr_conv_chain <- unlist(all_periods_3yr_conv, recursive = FALSE)

# make a reference grid 
ref_3yr_conv <- names(all_periods_3yr_conv_chain)

circ_3yr_conv <- circ(ref_3yr_conv)

full_circ_3yr_conv <- purrr::map(1:18,~all_periods_3yr_conv_chain[circ_3yr_conv[.x,]])
# name the nested list by the last element in each nested list
# the last element in each nested list appear in the same order as circ_3yr_conv[,12]

names(full_circ_3yr_conv) <- paste0(circ_3yr_conv[,18],"_contribution") 

# check if nested lists names matches their last elements' names: YES
# View( full_circ_2yr_conv) check

# remove the last subannual matrix from the chain in full_circ_3yr_conv
until_circ_3yr_conv <- full_circ_3yr_conv  %>%
  map(., ~{head(.,11)})

### low

# pick all phases in the 3yr low treatment
all_periods_3yr_low <- scenario1_projection_by_matrix_id_transpose[c("O3_low", "S3_low", "C3_low")]
#View(all_periods_2yr_conv)

# rearrange the phases in a chain
all_periods_3yr_low_chain <- unlist(all_periods_3yr_low, recursive = FALSE)

# make a reference grid 
ref_3yr_low <- names(all_periods_3yr_low_chain)

circ_3yr_low <- circ(ref_3yr_low)

full_circ_3yr_low <- purrr::map(1:18,~all_periods_3yr_low_chain[circ_3yr_low[.x,]])
# name the nested list by the last element in each nested list
# the last element in each nested list appear in the same order as circ_3yr_low[,12]

names(full_circ_3yr_low) <- paste0(circ_3yr_low[,18],"_contribution") 

# check if nested lists names matches their last elements' names: YES
# View( full_circ_3yr_low) 

# remove the last subannual matrix from the chain in full_circ_3yr_low
until_circ_3yr_low <- full_circ_3yr_low %>%
  map(., ~{head(.,11)})
```

```{r LTRE-3yr}
## In all LTRE procedures, the conventional treatment is the reference matrix and low the

# left matrix multiplication of all chains (as defined by starting point, aka the right-most matrix of the chain) THROUGH the right-most matrix --> matrix A's
A3_conv_contribution <- full_circ_3yr_conv %>% 
  map(., ~{Reduce( "%*%", .)}) 

A3_low_contribution <- full_circ_3yr_low %>% 
  map(., ~{Reduce( "%*%", .)}) 

A3_contribution <- lst(A3_conv_contribution, A3_low_contribution)

A3_avg_contribution <- lapply(Reduce(\(...)Map('+', ...), A3_contribution), '/', length(A3_contribution))

# Sensitivities with regards to the right-most matrix --> matrix S_a's
A3_avg_sens <- A3_avg_contribution %>%
  map(., ~{sensitivity(.)})

# left matrix multiplication of all chains (as defined by starting point, aka the right-most matrix of the chain) UNTIL the right-most matrix appear --> matrix D's

D3_conv_contribution <- until_circ_3yr_conv %>% 
  map(., ~{Reduce( "%*%", .)}) 

D3_low_contribution <- until_circ_3yr_low %>% 
  map(., ~{Reduce( "%*%", .)}) 

D3_contribution <- lst(D3_conv_contribution, D3_low_contribution)

D3_avg_contribution <- lapply(Reduce(\(...)Map('+', ...), D3_contribution), '/', length(D3_contribution))

contribution_3yr <- purrr::map2(D3_avg_contribution, A3_avg_sens, `%*%`)

# remove "conv" in all names
contribution_3yr_raw_names <- names( contribution_3yr )

contribution_3yr_names <- gsub('conv.', '', contribution_3yr_raw_names)

names(contribution_3yr) <- contribution_3yr_names
```

```{r circ-4yr-arrange}
### conventional 

# pick all phases in the 4yr conventional treatment
all_periods_4yr_conv <- scenario1_projection_by_matrix_id_transpose[c("A4_conv", "O4_conv", "S4_conv", "C4_conv")]
# View(all_periods_4yr_conv)

# rearrange the phases in a chain
all_periods_4yr_conv_chain <- unlist(all_periods_4yr_conv, recursive = FALSE)

# make a reference grid 
ref_4yr_conv <- names(all_periods_4yr_conv_chain)

circ_4yr_conv <- circ(ref_4yr_conv)

full_circ_4yr_conv <- purrr::map(1:24,~all_periods_4yr_conv_chain[circ_4yr_conv[.x,]])
# name the nested list by the last element in each nested list
# the last element in each nested list appear in the same order as circ_4yr_conv[,12]

names(full_circ_4yr_conv) <- paste0(circ_4yr_conv[,24],"_contribution") 

# check if nested lists names matches their last elements' names: YES
# View( full_circ_4yr_conv) check

# remove the last subannual matrix from the chain in full_circ_3yr_conv
until_circ_4yr_conv <- full_circ_4yr_conv  %>%
  map(., ~{head(.,11)})

### low

# pick all phases in the 3yr low treatment
all_periods_4yr_low <- scenario1_projection_by_matrix_id_transpose[c("A4_low", "O4_low", "S4_low", "C4_low")]
#View(all_periods_4yr_conv)

# rearrange the phases in a chain
all_periods_4yr_low_chain <- unlist(all_periods_4yr_low, recursive = FALSE)

# make a reference grid 
ref_4yr_low <- names(all_periods_4yr_low_chain)

circ_4yr_low <- circ(ref_4yr_low)

full_circ_4yr_low <- purrr::map(1:24,~all_periods_4yr_low_chain[circ_4yr_low[.x,]])
# name the nested list by the last element in each nested list
# the last element in each nested list appear in the same order as circ_4yr_low[,12]

names(full_circ_4yr_low) <- paste0(circ_4yr_low[,24],"_contribution") 

# check if nested lists names matches their last elements' names: YES
# View( full_circ_4yr_low) 

# remove the last subannual matrix from the chain in full_circ_4yr_low
until_circ_4yr_low <- full_circ_4yr_low %>%
  map(., ~{head(.,11)})
```


```{r LTRE-4yr}
## In all LTRE procedures, the conventional treatment is the reference matrix and low the

# left matrix multiplication of all chains (as defined by starting point, aka the right-most matrix of the chain) THROUGH the right-most matrix --> matrix A's
A4_conv_contribution <- full_circ_4yr_conv %>% 
  map(., ~{Reduce( "%*%", .)}) 

A4_low_contribution <- full_circ_4yr_low %>% 
  map(., ~{Reduce( "%*%", .)}) 

A4_contribution <- lst(A4_conv_contribution, A4_low_contribution)

A4_avg_contribution <- lapply(Reduce(\(...)Map('+', ...), A4_contribution), '/', length(A4_contribution))

# Sensitivities with regards to the right-most matrix --> matrix S_A's
A4_avg_sens <- A4_avg_contribution %>%
  map(., ~{sensitivity(.)})

# left matrix multiplication of all chains (as defined by starting point, aka the right-most matrix of the chain) UNTIL the right-most matrix appear --> matrix D's

D4_conv_contribution <- until_circ_4yr_conv %>% 
  map(., ~{Reduce( "%*%", .)}) 

D4_low_contribution <- until_circ_4yr_low %>% 
  map(., ~{Reduce( "%*%", .)}) 

D4_contribution <- lst(D4_conv_contribution, D4_low_contribution)

D4_avg_contribution <- lapply(Reduce(\(...)Map('+', ...), D4_contribution), '/', length(D4_contribution))

D4_avg_contribution_transposed <- D4_avg_contribution %>% map(.,~{t(.)})

## contribution of each sub-annual matrix to lambda's sensitivities, matrix S_B's                                     
sens_contribution_4yr <- purrr::map2(D4_avg_contribution_transposed, A4_avg_sens, `%*%`)
# remove "conv" in all names
sens_contribution_4yr_raw_names <- names( sens_contribution_4yr )

sens_contribution_4yr_names <- gsub('conv.', '', sens_contribution_4yr_raw_names)

names(sens_contribution_4yr) <- sens_contribution_4yr_names
```

```{r elasticity-4yr}
## calculate elasticity, see p. 121

## NEED NEW NAMES FOR ALL THE LIST
# lambda at scenario1_rotation_wise_lambda 
lambda_4yr_conv <- scenario1_rotation_wise_lambda$scenario1_rotation_wise_4yr_conv$lambda1 

lambda_4yr_low <- scenario1_rotation_wise_lambda$scenario1_rotation_wise_4yr_low$lambda1 
# Elasticity contribution left: check if all_periods_4yr_conv_chain is the appropriate element 
# The right-most matrix of all_periods_4yr_conv_chain is C4_spring_tillage
# why is the order of "all_periods_4yr_conv_chain" and "sens_contribution_4yr" opposite?


A4_conv_elas_left <-  all_periods_4yr_conv_chain %>%
  map(., ~{./lambda_4yr_conv})

A4_low_elas_left <-  all_periods_4yr_low_chain %>%
  map(., ~{./lambda_4yr_low})

# Elasticity contribution right: S_B's sens_contribution_4yr

# Elasticity
elas_contribution_4yr_conv <- Map(\(x, y) Reduce(`%*%`, list(x, y)), A4_conv_elas_left, sens_contribution_4yr)

```
