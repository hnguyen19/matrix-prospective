---
output:
  #  bookdown::word_document2:
    bookdown::html_document2:
      toc: false
      fig_caption: yes
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(purrr) # for map2()
library(pracma)
library(popbio)
library(tidyverse)
library(magrittr) 
# convert this Rmd to R to source it in results.Rmd
library(flextable)
source("functions.R")
```


```{r scenario1-periodic-matrices-phases-mean, include=FALSE}
## Summary: everything the same in all scenarios, but:
# mean_emergence:
# summer survival: literature
# Fecundity: 2019
# Overwinter survival: Sosnoskie et al. AMAPA

## Pre-planting tillage 
mean_spring_tillage <-  readRDS("../2-Data/Clean/mean-pre-planting-tillage.RData")

## Emergence 
scenario1_mean_emergence <- readRDS("../2-Data/Clean/mean-emergence-prop-adjusted.RData")

## Seed survival and plant survival 
#### seed survival 

scenario1_mean_summer_seed_survival <- readRDS("../2-Data/Clean/mean-summer-seed-survival-Sosnoskie.RData")

#### plant survival: literature data - named as scenario2, because scenario1 is the point-estimates from the experiment 
#female_survival <- readRDS("../2-Data/Clean/female-survival-rate-cohort-equal.RData")

scenario1_mean_female_survival <- readRDS("../2-Data/Clean/mean-summer-seedling-survival-Hartzler.RData")

#### combine seed and plant survivals into one matrix with element-wise multiplication: this is not computing, but arranging using 1's as placeholders 
scenario1_mean_summer_survival <- purrr::map2(scenario1_mean_summer_seed_survival, scenario1_mean_female_survival, `*`)

## Fecundity: next chunk

## Post-harvest tillage
mean_post_harvest_tillage <- readRDS("../2-Data/Clean/mean-post-harvest-tillage.RData")

## Overwinter survival 
scenario1_mean_overwinter <- readRDS("../2-Data/Clean/mean-winter-seed-survival-Sosnoskie.RData")

```

```{r scenario1-phase-wise-projection-1, include=FALSE}
## Circle starts at spring tillage Fecundity scenario 1 - 2019 rates
scenario1_mean_fecundity_2019 <- readRDS("../2-Data/Clean/mean-fecundity-19-cohort.RData")



scenario1_projection_by_matrix_id <- tibble::lst(scenario1_mean_overwinter,
                                                 mean_post_harvest_tillage,
                                                 scenario1_mean_fecundity_2019,
                                                 scenario1_mean_summer_survival,
                                               scenario1_mean_emergence,
                                               mean_spring_tillage)
## name column and row 
scenario1_projection_by_matrix_id_named <- rapply(scenario1_projection_by_matrix_id, 
                                                  function(x) {dimnames(x) <- rep(list(c("s_t",
                                                                                        "s_b", 
                                                                                        "p_co_1",
                                                                                        "p_co_2",
                                                                                        "p_co_3",
                                                                                        "p_co_4",
                                                                                        "p_co_5",
                                                                                        "p_co_6")),2); x}, how="list")

# View(scenario1_projection_by_matrix_id_named )

## List all periodic matrices within the same crop ID together  
scenario1_projection_by_matrix_id_transpose <- purrr::transpose(scenario1_projection_by_matrix_id_named )

# multiply all the periodic matrices within a crop ID 

scenario1_phase_projection <- scenario1_projection_by_matrix_id_transpose  %>%
  map(., ~{Reduce( "%*%", .)}) 

# check 
#lapply(scenario1_projection_by_matrix_id_transpose, 
#       \(x) x[[1]] %*% x[[2]] %*% x[[3]] %*% x[[4]] %*% x[[5]] %*% x[[6]])

# View(scenario1_phase_projection)
```


```{r scenario1-rotation-group, include=FALSE}
## Separate scenario1_phase_projection by rotation x corn weed management 
# Phases are listed right to left, which is the opposite to their orders 
#2year, conventional
scenario1_rotation_wise_2yr_conv <- scenario1_phase_projection[c("S2_conv", "C2_conv")] #View(scenario1_rotation_wise_2yr_conv)

#2year, low
scenario1_rotation_wise_2yr_low <- scenario1_phase_projection[c("S2_low","C2_low")]
#3-year, conventional
scenario1_rotation_wise_3yr_conv <- scenario1_phase_projection[c("O3_conv", "S3_conv", "C3_conv")]
#View(scenario1_rotation_wise_3yr_conv)

#3-year, low
scenario1_rotation_wise_3yr_low <- scenario1_phase_projection[c("O3_low", "S3_low", "C3_low")]

scenario1_rotation_wise_4yr_conv <- scenario1_phase_projection[c("A4_conv", "O4_conv", "S4_conv", "C4_conv")]

#4-year, low
scenario1_rotation_wise_4yr_low <- scenario1_phase_projection[c("A4_low", "O4_low", "S4_low", "C4_low")]
```


```{r scenario1-phase-wise-lambda-plot-prep, echo=FALSE}
## trim off the trailing zeros 
scenario1_phase_projection_trimmed <- rapply(scenario1_phase_projection, \(x) matrix_trim(x), how = "list")


# View(scenario1_phase_projection_trimmed)

## For all cropping systems, start with the same N0
N0 <- matrix(c(1000,0),nrow = 2)

##Split scenario1_phase_projection_trimmed into 18 data
for (i in seq_along(scenario1_phase_projection_trimmed)) {
    assign(names(scenario1_phase_projection_trimmed)[i], scenario1_phase_projection_trimmed[[i]], .GlobalEnv)
}

## Calculate population after each crop phase, for 12 year
## 2 year, conv
col_names <- c("N0", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "N8", "N9", "N10", "N11", "N12")
### 2-year conv
scenario1_N2yr_conv <- data.frame(matrix(ncol = 13, nrow = 2))
names(scenario1_N2yr_conv ) <- col_names 
scenario1_N2yr_conv$N0 <- N0
scenario1_N2yr_conv$N1 <- C2_conv %*% N0 
scenario1_N2yr_conv$N2 <- S2_conv %*% scenario1_N2yr_conv$N1
scenario1_N2yr_conv$N3 <- C2_conv %*% scenario1_N2yr_conv$N2 
scenario1_N2yr_conv$N4 <- S2_conv %*% scenario1_N2yr_conv$N3 
scenario1_N2yr_conv$N5 <- C2_conv %*% scenario1_N2yr_conv$N4 
scenario1_N2yr_conv$N6 <- S2_conv %*% scenario1_N2yr_conv$N5 
scenario1_N2yr_conv$N7 <- C2_conv %*% scenario1_N2yr_conv$N6 
scenario1_N2yr_conv$N8 <- S2_conv %*% scenario1_N2yr_conv$N7 
scenario1_N2yr_conv$N9 <- C2_conv %*% scenario1_N2yr_conv$N8 
scenario1_N2yr_conv$N10 <- S2_conv %*% scenario1_N2yr_conv$N9 
scenario1_N2yr_conv$N11 <- C2_conv %*% scenario1_N2yr_conv$N10 
scenario1_N2yr_conv$N12 <- S2_conv %*% scenario1_N2yr_conv$N11 

### 2-year low
scenario1_N2yr_low <- data.frame(matrix(ncol = 13, nrow = 2))
names(scenario1_N2yr_low ) <- col_names 
scenario1_N2yr_low$N0 <- N0
scenario1_N2yr_low$N1 <- C2_low %*% N0 
scenario1_N2yr_low$N2 <- S2_low %*% scenario1_N2yr_low$N1
scenario1_N2yr_low$N3 <- C2_low %*% scenario1_N2yr_low$N2 
scenario1_N2yr_low$N4 <- S2_low %*% scenario1_N2yr_low$N3 
scenario1_N2yr_low$N5 <- C2_low %*% scenario1_N2yr_low$N4 
scenario1_N2yr_low$N6 <- S2_low %*% scenario1_N2yr_low$N5 
scenario1_N2yr_low$N7 <- C2_low %*% scenario1_N2yr_low$N6 
scenario1_N2yr_low$N8 <- S2_low %*% scenario1_N2yr_low$N7 
scenario1_N2yr_low$N9 <- C2_low %*% scenario1_N2yr_low$N8 
scenario1_N2yr_low$N10 <- S2_low %*% scenario1_N2yr_low$N9 
scenario1_N2yr_low$N11 <- C2_low %*% scenario1_N2yr_low$N10 
scenario1_N2yr_low$N12 <- S2_low %*% scenario1_N2yr_low$N11 

### 3-year conv
scenario1_N3yr_conv <- data.frame(matrix(ncol = 13, nrow = 2))
names(scenario1_N3yr_conv ) <- col_names 
scenario1_N3yr_conv$N0 <- N0
scenario1_N3yr_conv$N1 <- C3_conv %*% N0 
scenario1_N3yr_conv$N2 <- S3_conv %*% scenario1_N3yr_conv$N1
scenario1_N3yr_conv$N3 <- O3_conv %*% scenario1_N3yr_conv$N2 
scenario1_N3yr_conv$N4 <- C3_conv %*% scenario1_N3yr_conv$N3 
scenario1_N3yr_conv$N5 <- S3_conv %*% scenario1_N3yr_conv$N4
scenario1_N3yr_conv$N6 <- O3_conv %*% scenario1_N3yr_conv$N5 
scenario1_N3yr_conv$N7 <- C3_conv %*% scenario1_N3yr_conv$N6 
scenario1_N3yr_conv$N8 <- S3_conv %*% scenario1_N3yr_conv$N7
scenario1_N3yr_conv$N9 <- O3_conv %*% scenario1_N3yr_conv$N8 
scenario1_N3yr_conv$N10 <- C3_conv %*% scenario1_N3yr_conv$N9 
scenario1_N3yr_conv$N11 <- S3_conv %*% scenario1_N3yr_conv$N10
scenario1_N3yr_conv$N12 <- O3_conv %*% scenario1_N3yr_conv$N11 


### 3-year low
scenario1_N3yr_low <- data.frame(matrix(ncol = 13, nrow = 2))
names(scenario1_N3yr_low ) <- col_names 
scenario1_N3yr_low$N0 <- N0
scenario1_N3yr_low$N1 <- C3_low %*% N0 
scenario1_N3yr_low$N2 <- S3_low %*% scenario1_N3yr_low$N1
scenario1_N3yr_low$N3 <- O3_low %*% scenario1_N3yr_low$N2 
scenario1_N3yr_low$N4 <- C3_low %*% scenario1_N3yr_low$N3 
scenario1_N3yr_low$N5 <- S3_low %*% scenario1_N3yr_low$N4
scenario1_N3yr_low$N6 <- O3_low %*% scenario1_N3yr_low$N5 
scenario1_N3yr_low$N7 <- C3_low %*% scenario1_N3yr_low$N6 
scenario1_N3yr_low$N8 <- S3_low %*% scenario1_N3yr_low$N7
scenario1_N3yr_low$N9 <- O3_low %*% scenario1_N3yr_low$N8 
scenario1_N3yr_low$N10 <- C3_low %*% scenario1_N3yr_low$N9 
scenario1_N3yr_low$N11 <- S3_low %*% scenario1_N3yr_low$N10
scenario1_N3yr_low$N12 <- O3_low %*% scenario1_N3yr_low$N11 

### 4-year conv
scenario1_N4yr_conv <- data.frame(matrix(ncol = 13, nrow = 2))
names(scenario1_N4yr_conv ) <- col_names 
scenario1_N4yr_conv$N0 <- N0
scenario1_N4yr_conv$N1 <- C4_conv %*% N0 
scenario1_N4yr_conv$N2 <- S4_conv %*% scenario1_N4yr_conv$N1
scenario1_N4yr_conv$N3 <- O4_conv %*% scenario1_N4yr_conv$N2 
scenario1_N4yr_conv$N4 <- A4_conv %*% scenario1_N4yr_conv$N3 
scenario1_N4yr_conv$N5 <- C4_conv %*% scenario1_N4yr_conv$N4 
scenario1_N4yr_conv$N6 <- S4_conv %*% scenario1_N4yr_conv$N5
scenario1_N4yr_conv$N7 <- O4_conv %*% scenario1_N4yr_conv$N6 
scenario1_N4yr_conv$N8 <- A4_conv %*% scenario1_N4yr_conv$N7 
scenario1_N4yr_conv$N9 <- C4_conv %*% scenario1_N4yr_conv$N8  
scenario1_N4yr_conv$N10 <- S4_conv %*% scenario1_N4yr_conv$N9
scenario1_N4yr_conv$N11 <- O4_conv %*% scenario1_N4yr_conv$N10 
scenario1_N4yr_conv$N12 <- A4_conv %*% scenario1_N4yr_conv$N11 

### 4-year low
scenario1_N4yr_low <- data.frame(matrix(ncol = 13, nrow = 2))
names(scenario1_N4yr_low ) <- col_names 
scenario1_N4yr_low$N0 <- N0
scenario1_N4yr_low$N1 <- C4_low %*% N0 
scenario1_N4yr_low$N2 <- S4_low %*% scenario1_N4yr_low$N1
scenario1_N4yr_low$N3 <- O4_low %*% scenario1_N4yr_low$N2 
scenario1_N4yr_low$N4 <- A4_low %*% scenario1_N4yr_low$N3 
scenario1_N4yr_low$N5 <- C4_low %*% scenario1_N4yr_low$N4 
scenario1_N4yr_low$N6 <- S4_low %*% scenario1_N4yr_low$N5
scenario1_N4yr_low$N7 <- O4_low %*% scenario1_N4yr_low$N6 
scenario1_N4yr_low$N8 <- A4_low %*% scenario1_N4yr_low$N7 
scenario1_N4yr_low$N9 <- C4_low %*% scenario1_N4yr_low$N8  
scenario1_N4yr_low$N10 <- S4_low %*% scenario1_N4yr_low$N9
scenario1_N4yr_low$N11 <- O4_low %*% scenario1_N4yr_low$N10 
scenario1_N4yr_low$N12 <- A4_low %*% scenario1_N4yr_low$N11 

#View(scenario1_N4yr_low )

## combine all the 6 crop id x corn weed management
scenario1_phase_seed_vectors <- rbind(scenario1_N2yr_conv,
                                      scenario1_N2yr_low,
                                      scenario1_N3yr_conv,
                                      scenario1_N3yr_low,
                                      scenario1_N4yr_conv,
                                      scenario1_N4yr_low)

```


```{r scenario1-eigen-rotation, echo=FALSE}
scenario1_rotation_group <- tibble::lst(scenario1_rotation_wise_2yr_conv,
                                     scenario1_rotation_wise_2yr_low,
                                     scenario1_rotation_wise_3yr_conv,
                                     scenario1_rotation_wise_3yr_low,
                                     scenario1_rotation_wise_4yr_conv,
                                     scenario1_rotation_wise_4yr_low)

scenario1_rotation_wise_projection <- scenario1_rotation_group %>%
  map(., ~{Reduce( "%*%", .)}) 

scenario1_rotation_wise_eigen <- scenario1_rotation_wise_projection %>%
  map(., ~{eigen.analysis(.)}) 

```

```{r scenario1-rotation-lambda, echo=FALSE}
scenario1_rotation_wise_lambda <- scenario1_rotation_wise_eigen %>%
  map(., ~{head(.,1)}) 

# make a df to admend to the next chunk's df 

scenario1_rotation_wise_lambda_df <- scenario1_rotation_wise_lambda %>%
   plyr::ldply(., data.frame)
```



```{r scenario1-lambda-annualized-df, echo=FALSE}
scenario1_annualized_lambda_2yr <- rapply(scenario1_rotation_wise_lambda[1:2],
                                             function(x){nthroot(x,2)}, how = "list")    

scenario1_annualized_lambda_3yr <- rapply(scenario1_rotation_wise_lambda[3:4],
                                             function(x){nthroot(x,3)}, how = "list")

scenario1_annualized_lambda_4yr <- rapply(scenario1_rotation_wise_lambda[5:6],
                                             function(x){nthroot(x,4)}, how = "list")
   
scenario1_annualized_lambda_df <- tibble::lst(scenario1_annualized_lambda_2yr,
                                   scenario1_annualized_lambda_3yr,
                                   scenario1_annualized_lambda_4yr) %>%
   plyr::ldply(., data.frame) %>% 
  rename(conv = "lambda1", low = "lambda1.1")

scenario1_annualized_lambda_df_long <- scenario1_annualized_lambda_df %>%
  pivot_longer(!.id, names_to = "Corn_weed_management", values_to = "annualized_lambda") 

# View(scenario1_annualized_lambda_df_long)

## add the rotation-wise lambdas to the annualized lambdas 
scenario1_annualized_lambda_df_long$rot_wise_lambda <-  scenario1_rotation_wise_lambda_df$lambda1
```


```{r scenario1-circ-2yr-arrange, echo=FALSE, warning=FALSE, message=FALSE}
### conventional 

# pick all phases in the 2yr conventional treatment and arrange in backward order, i.e., first sub-annual matrix in the first crop phase at the right-most (or bottom) position of the list
scenario1_all_periods_2yr_conv <- scenario1_projection_by_matrix_id_transpose[c("S2_conv", "C2_conv")]
#View(scenario1_all_periods_2yr_conv)

# remove the phase bounded structure in a chain, making a chain of 12 subannual matrices for the 2-year rotation
scenario1_all_periods_2yr_conv_chain <- unlist(scenario1_all_periods_2yr_conv, recursive = FALSE)

# make a reference grid, based on a chain starting at the spring_tillage matrix
scenario1_ref_2yr_conv <- names(scenario1_all_periods_2yr_conv_chain)

# create circular rotation of the first subannual matrix in each chain
scenario1_circ_2yr_conv <- circ(scenario1_ref_2yr_conv)

scenario1_full_circ_2yr_conv <- purrr::map(1:12,~scenario1_all_periods_2yr_conv_chain[scenario1_circ_2yr_conv[.x,]])
# name the nested list by the last element in each nested list
# the last element in each nested list appear in the same order as circ_2yr_conv[,12]

names(scenario1_full_circ_2yr_conv) <- paste0(scenario1_circ_2yr_conv[,12],"_contribution") 

# check if nested lists names matches their last elements' names: YES
# View( scenario1_full_circ_2yr_conv) check

# remove the last subannual matrix from the chain in full_circ_2yr_conv:
scenario1_until_circ_2yr_conv <- scenario1_full_circ_2yr_conv  %>%
  map(., ~{head(.,11)})
#  Each chain now has 11 matrixe. In term of contribution to changes in lambda, each chain starts at the subannual matrix following the matrix of interest. The `until` and `though` designation is detailed in Caswell and Trevisan 1994. 
### low

# pick all phases in the 2yr conventional treatment
scenario1_all_periods_2yr_low <- scenario1_projection_by_matrix_id_transpose[c("S2_low", "C2_low")]
#View(all_periods_2yr_conv)

# rearrange the phases in a chain
scenario1_all_periods_2yr_low_chain <- unlist(scenario1_all_periods_2yr_low, recursive = FALSE)

# make a reference grid 
scenario1_ref_2yr_low <- names(scenario1_all_periods_2yr_low_chain)

scenario1_circ_2yr_low <- circ(scenario1_ref_2yr_low)

scenario1_full_circ_2yr_low <- purrr::map(1:12,~scenario1_all_periods_2yr_low_chain[scenario1_circ_2yr_low[.x,]])
# name the nested list by the last element in each nested list
# the last element in each nested list appear in the same order as circ_2yr_low[,12]

names(scenario1_full_circ_2yr_low) <- paste0(scenario1_circ_2yr_low[,12],"_contribution") 

# check if nested lists names matches their last elements' names: YES
# View( full_circ_2yr_low): each chain's product is identified by the right-most matrix 

# remove the last subannual matrix from the chain in full_circ_2yr_low
scenario1_until_circ_2yr_low <- scenario1_full_circ_2yr_low %>%
  map(., ~{head(.,11)})
```


```{r scenario1-LTRE-2yr, echo=FALSE}
## In all LTRE procedures, the conventional treatment is the reference matrix and low the treatment of interest

# left matrix multiplication of all chains (as defined by starting point, aka the right-most matrix of the chain) THROUGH the right-most matrix --> matrix A's

# The product of each list in the full_circ_2yr_xx is A(hk),
# A(hk) is the product of all sub-annual period starting at phase k, period h
scenario1_A2_conv_contribution <- scenario1_full_circ_2yr_conv %>%  
  map(., ~{Reduce( "%*%", .)}) 

scenario1_A2_low_contribution <- scenario1_full_circ_2yr_low %>% 
  map(., ~{Reduce( "%*%", .)}) 

scenario1_A2_contribution <- lst(scenario1_A2_conv_contribution, scenario1_A2_low_contribution)

# calculate the A* matrix, average of the two products representing conventional and low corn weed management treatments 

scenario1_A2_avg_contribution <- lapply(Reduce(\(...)Map('+', ...), scenario1_A2_contribution), '/', length(scenario1_A2_contribution))

# Matrix S_A(h)'s: sensitivity of lambda to each element of A(h), i.e. a(ijh), using matrix A*
scenario1_A2_avg_sens <- scenario1_A2_avg_contribution %>%
  map(., ~{sensitivity(.)})

# Matrix D: the product of all sub-annual matrices in backward order, until the B(h) matrix appear. 
# other words: left matrix multiplication of all chains (as defined by starting point, B(h), UNTIL the B(h) appear, the chain that makes up D is one matrix fewer than one that makes S

scenario1_D2_conv_contribution <- scenario1_until_circ_2yr_conv %>% 
  map(., ~{Reduce( "%*%", .)}) 

scenario1_D2_low_contribution <- scenario1_until_circ_2yr_low %>% 
  map(., ~{Reduce( "%*%", .)}) 

scenario1_D2_contribution <- lst(scenario1_D2_conv_contribution, scenario1_D2_low_contribution)

### Do I really need D_avg? ### Yes

scenario1_D2_avg_contribution <- lapply(Reduce(\(...)Map('+', ...), scenario1_D2_contribution), '/', length(scenario1_D2_contribution))

scenario1_D2_avg_contribution_transposed <- scenario1_D2_avg_contribution %>%
  map(., ~{t(.)})

# Matrix S_B(h):  sensitivity of lambda to changes in each element of the subannual matrix B(h)  
scenario1_S_B_contribution_2yr <- purrr::map2(scenario1_D2_avg_contribution_transposed, scenario1_A2_avg_sens, `%*%`)

# remove "conv" in all names, conv was picked up from D2_conv_contribution because it was listed first in D2_contribution. 

## pick out the names
scenario1_contribution_2yr_raw_names <- names( scenario1_S_B_contribution_2yr)

## remove "conv" in all names
scenario1_contribution_2yr_names <- gsub('conv.', '', scenario1_contribution_2yr_raw_names)
## put the names back
names(scenario1_S_B_contribution_2yr) <- scenario1_contribution_2yr_names

# View(scenario1_S_B_contribution_2yr )
```



```{r scenario1-elasticity-2yr, echo=FALSE}
# lambda at scenario1_annualized_lambda_df_long$annualized_lamb View(scenario1_annualized_lambda_df_long)
scenario1_lambda_2yr_conv <- scenario1_annualized_lambda_df_long$annualized_lambda[1]

scenario1_lambda_2yr_low <-scenario1_annualized_lambda_df_long$annualized_lambda[2]
# Elasticity contribution left: check if all_periods_2yr_conv_chain is the appropriate element 
# The right-most matrix of all_periods_2yr_conv_chain is C2_spring_tillage
# why is the order of "all_periods_2yr_conv_chain" and "sens_contribution_2yr" opposite?

# Elasticity contribution left component: b_hij_2/lambda, or _3, _4 in the later chunks 
scenario1_b_hij_2_over_lambda_conv <-  scenario1_all_periods_2yr_conv_chain %>%
  map(., ~{./scenario1_lambda_2yr_conv})

scenario1_b_hij_2_over_lambda_low <-  scenario1_all_periods_2yr_low_chain %>%
  map(., ~{./scenario1_lambda_2yr_low})

# Elasticity contribution right component: S_B's 

# Multiply the left and right components 
scenario1_E_B_contribution_2yr_conv <- Map(\(x, y) Reduce(`%*%`, list(x, y)), scenario1_b_hij_2_over_lambda_conv, scenario1_S_B_contribution_2yr)

## pick out the names
scenario1_E_B_contribution_2yr_conv_raw_names <- names(scenario1_E_B_contribution_2yr_conv )

## rename "means" with "E_B" in list names, for identification

scenario1_E_B_contribution_2yr_conv_names <- gsub('mean', 'E_B', scenario1_E_B_contribution_2yr_conv_raw_names )
## put the names back
names(scenario1_E_B_contribution_2yr_conv ) <- scenario1_E_B_contribution_2yr_conv_names 

scenario1_E_B_contribution_2yr_low <- Map(\(x, y) Reduce(`%*%`, list(x, y)), scenario1_b_hij_2_over_lambda_low, scenario1_S_B_contribution_2yr)

## pick out the names
scenario1_E_B_contribution_2yr_low_raw_names <- names(scenario1_E_B_contribution_2yr_low)

## rename "means" with "E_B" in list names, for identification

scenario1_E_B_contribution_2yr_low_names <- gsub('mean', 'E_B', scenario1_E_B_contribution_2yr_low_raw_names )
## put the names back
names(scenario1_E_B_contribution_2yr_low ) <- scenario1_E_B_contribution_2yr_low_names 

```

```{r scenario1-circ-3yr-arrange, echo=FALSE, warning=FALSE, message=FALSE}
### conventional 

# pick all phases in the 3yr conventional treatment
scenario1_all_periods_3yr_conv <- scenario1_projection_by_matrix_id_transpose[c("O3_conv", "S3_conv", "C3_conv")]
#View(all_periods_3yr_conv)

# rearrange the phases in a chain
scenario1_all_periods_3yr_conv_chain <- unlist(scenario1_all_periods_3yr_conv, recursive = FALSE)

# make a reference grid 
scenario1_ref_3yr_conv <- names(scenario1_all_periods_3yr_conv_chain)

scenario1_circ_3yr_conv <- circ(scenario1_ref_3yr_conv)

scenario1_full_circ_3yr_conv <- purrr::map(1:18,~scenario1_all_periods_3yr_conv_chain[scenario1_circ_3yr_conv[.x,]])
# name the nested list by the last element in each nested list
# the last element in each nested list appear in the same order as circ_3yr_conv[,12]

names(scenario1_full_circ_3yr_conv) <- paste0(scenario1_circ_3yr_conv[,18],"_contribution") 

# check if nested lists names matches their last elements' names: YES
# View( full_circ_2yr_conv) check

# remove the last subannual matrix from the chain in full_circ_3yr_conv
scenario1_until_circ_3yr_conv <- scenario1_full_circ_3yr_conv  %>%
  map(., ~{head(.,11)})

### low

# pick all phases in the 3yr low treatment
scenario1_all_periods_3yr_low <- scenario1_projection_by_matrix_id_transpose[c("O3_low", "S3_low", "C3_low")]
#View(all_periods_2yr_conv)

# rearrange the phases in a chain
scenario1_all_periods_3yr_low_chain <- unlist(scenario1_all_periods_3yr_low, recursive = FALSE)

# make a reference grid 
scenario1_ref_3yr_low <- names(scenario1_all_periods_3yr_low_chain)

scenario1_circ_3yr_low <- circ(scenario1_ref_3yr_low)

scenario1_full_circ_3yr_low <- purrr::map(1:18,~scenario1_all_periods_3yr_low_chain[scenario1_circ_3yr_low[.x,]])
# name the nested list by the last element in each nested list
# the last element in each nested list appear in the same order as circ_3yr_low[,12]

names(scenario1_full_circ_3yr_low) <- paste0(scenario1_circ_3yr_low[,18],"_contribution") 

# check if nested lists names matches their last elements' names: YES
# View( scenario1_full_circ_3yr_low) 

# remove the last subannual matrix from the chain in full_circ_3yr_low
scenario1_until_circ_3yr_low <- scenario1_full_circ_3yr_low %>%
  map(., ~{head(.,11)})
```

```{r scenario1-LTRE-3yr, echo=FALSE}
## In all LTRE procedures, the conventional treatment is the reference matrix and low the

# left matrix multiplication of all chains (as defined by starting point, aka the right-most matrix of the chain) THROUGH the right-most matrix --> matrix A's
scenario1_A3_conv_contribution <- scenario1_full_circ_3yr_conv %>% 
  map(., ~{Reduce( "%*%", .)}) 

scenario1_A3_low_contribution <- scenario1_full_circ_3yr_low %>% 
  map(., ~{Reduce( "%*%", .)}) 

scenario1_A3_contribution <- lst(scenario1_A3_conv_contribution, scenario1_A3_low_contribution)

scenario1_A3_avg_contribution <- lapply(Reduce(\(...)Map('+', ...), scenario1_A3_contribution), '/', length(scenario1_A3_contribution))

# Sensitivities with regards to the right-most matrix --> matrix S_a's
scenario1_A3_avg_sens <- scenario1_A3_avg_contribution %>%
  map(., ~{sensitivity(.)})

# left matrix multiplication of all chains (as defined by starting point, aka the right-most matrix of the chain) UNTIL the right-most matrix appear --> matrix D's

scenario1_D3_conv_contribution <- scenario1_until_circ_3yr_conv %>% 
  map(., ~{Reduce( "%*%", .)}) 

scenario1_D3_low_contribution <- scenario1_until_circ_3yr_low %>% 
  map(., ~{Reduce( "%*%", .)}) 

scenario1_D3_contribution <- lst(scenario1_D3_conv_contribution, scenario1_D3_low_contribution)

scenario1_D3_avg_contribution <- lapply(Reduce(\(...)Map('+', ...), scenario1_D3_contribution), '/', length(scenario1_D3_contribution))

scenario1_S_B_contribution_3yr <- purrr::map2(scenario1_D3_avg_contribution, scenario1_A3_avg_sens, `%*%`)

# remove "conv" in all names
scenario1_contribution_3yr_raw_names <- names(scenario1_S_B_contribution_3yr )

scenario1_contribution_3yr_names <- gsub('conv.', '', scenario1_contribution_3yr_raw_names)

names(scenario1_S_B_contribution_3yr) <- scenario1_contribution_3yr_names
```

```{r scenario1-elasticity-3yr, echo=FALSE}
# lambda at scenario1_rotation_wise_lambda 
scenario1_lambda_3yr_conv <- scenario1_annualized_lambda_df_long$annualized_lambda[3]

scenario1_lambda_3yr_low <- scenario1_annualized_lambda_df_long$annualized_lambda[4]


# Elasticity contribution left component: b_hij_3/lambda,
scenario1_b_hij_3yr_over_lambda_conv <-  scenario1_all_periods_3yr_conv_chain %>%
  map(., ~{./scenario1_lambda_3yr_conv})

scenario1_b_hij_3yr_over_lambda_low <-  scenario1_all_periods_3yr_low_chain %>%
  map(., ~{./scenario1_lambda_3yr_low})

# Elasticity contribution right component: S_B's 

# ## Calculate E_Bs: Multiply the left and right components 
scenario1_E_B_contribution_3yr_conv <- Map(\(x, y) Reduce(`%*%`, list(x, y)), scenario1_b_hij_3yr_over_lambda_conv, scenario1_S_B_contribution_3yr)
## pick out the names
scenario1_E_B_contribution_3yr_conv_raw_names <- names(scenario1_E_B_contribution_3yr_conv )

## rename "means" with "E_B" in list names, for identification

scenario1_E_B_contribution_3yr_conv_names <- gsub('mean', 'E_B', scenario1_E_B_contribution_3yr_conv_raw_names )
## put the names back
names(scenario1_E_B_contribution_3yr_conv ) <- scenario1_E_B_contribution_3yr_conv_names 


## Calculate E_Bs
scenario1_E_B_contribution_3yr_low <- Map(\(x, y) Reduce(`%*%`, list(x, y)), scenario1_b_hij_3yr_over_lambda_low, scenario1_S_B_contribution_3yr)

## pick out the names
scenario1_E_B_contribution_3yr_low_raw_names <- names(scenario1_E_B_contribution_3yr_low)

## rename "means" with "E_B" in list names, for identification

scenario1_E_B_contribution_3yr_low_names <- gsub('mean', 'E_B', scenario1_E_B_contribution_3yr_low_raw_names )
## put the names back
names(scenario1_E_B_contribution_3yr_low ) <- scenario1_E_B_contribution_3yr_low_names 
```

```{r scenario1-circ-4yr-arrange, echo=FALSE, warning=FALSE, message=FALSE}
### conventional 

# pick all phases in the 4yr conventional treatment
scenario1_all_periods_4yr_conv <- scenario1_projection_by_matrix_id_transpose[c("A4_conv", "O4_conv", "S4_conv", "C4_conv")]
# View(scenario1_all_periods_4yr_conv)

# rearrange the phases in a chain
scenario1_all_periods_4yr_conv_chain <- unlist(scenario1_all_periods_4yr_conv, recursive = FALSE)

# make a reference grid 
scenario1_ref_4yr_conv <- names(scenario1_all_periods_4yr_conv_chain)

scenario1_circ_4yr_conv <- circ(scenario1_ref_4yr_conv)

scenario1_full_circ_4yr_conv <- purrr::map(1:24,~scenario1_all_periods_4yr_conv_chain[scenario1_circ_4yr_conv[.x,]])
# name the nested list by the last element in each nested list
# the last element in each nested list appear in the same order as scenario1_circ_4yr_conv[,12]

names(scenario1_full_circ_4yr_conv) <- paste0(scenario1_circ_4yr_conv[,24],"_contribution") 

# check if nested lists names matches their last elements' names: YES
# View( scenario1_full_circ_4yr_conv) check

# remove the last subannual matrix from the chain in full_circ_3yr_conv
scenario1_until_circ_4yr_conv <- scenario1_full_circ_4yr_conv  %>%
  map(., ~{head(.,11)})

### low

# pick all phases in the 3yr low treatment
scenario1_all_periods_4yr_low <- scenario1_projection_by_matrix_id_transpose[c("A4_low", "O4_low", "S4_low", "C4_low")]
#View(all_periods_4yr_conv)

# rearrange the phases in a chain
scenario1_all_periods_4yr_low_chain <- unlist(scenario1_all_periods_4yr_low, recursive = FALSE)

# make a reference grid 
scenario1_ref_4yr_low <- names(scenario1_all_periods_4yr_low_chain)

scenario1_circ_4yr_low <- circ(scenario1_ref_4yr_low)

scenario1_full_circ_4yr_low <- purrr::map(1:24,~scenario1_all_periods_4yr_low_chain[scenario1_circ_4yr_low[.x,]])
# name the nested list by the last element in each nested list
# the last element in each nested list appear in the same order as scenario1_circ_4yr_low[,12]

names(scenario1_full_circ_4yr_low) <- paste0(scenario1_circ_4yr_low[,24],"_contribution") 

# check if nested lists names matches their last elements' names: YES
# View( scenario1_full_circ_4yr_low) 

# remove the last subannual matrix from the chain in full_circ_4yr_low
scenario1_until_circ_4yr_low <- scenario1_full_circ_4yr_low %>%
  map(., ~{head(.,11)})
```

```{r scenario1-LTRE-4yr, echo=FALSE}
## In all LTRE procedures, the conventional treatment is the reference matrix and low the

# left matrix multiplication of all chains (as defined by starting point, aka the right-most matrix of the chain) THROUGH the right-most matrix --> matrix A's
scenario1_A4_conv_contribution <- scenario1_full_circ_4yr_conv %>% 
  map(., ~{Reduce( "%*%", .)}) 

scenario1_A4_low_contribution <- scenario1_full_circ_4yr_low %>% 
  map(., ~{Reduce( "%*%", .)}) 

scenario1_A4_contribution <- lst(scenario1_A4_conv_contribution, scenario1_A4_low_contribution)

scenario1_A4_avg_contribution <- lapply(Reduce(\(...)Map('+', ...), scenario1_A4_contribution), '/', length(scenario1_A4_contribution))

# Sensitivities with regards to the right-most matrix --> matrix S_A's
scenario1_A4_avg_sens <- scenario1_A4_avg_contribution %>%
  map(., ~{sensitivity(.)})

# left matrix multiplication of all chains (as defined by starting point, aka the right-most matrix of the chain) UNTIL the right-most matrix appear --> matrix D's

scenario1_D4_conv_contribution <- scenario1_until_circ_4yr_conv %>% 
  map(., ~{Reduce( "%*%", .)}) 

scenario1_D4_low_contribution <- scenario1_until_circ_4yr_low %>% 
  map(., ~{Reduce( "%*%", .)}) 

scenario1_D4_contribution <- lst(scenario1_D4_conv_contribution, scenario1_D4_low_contribution)

scenario1_D4_avg_contribution <- lapply(Reduce(\(...)Map('+', ...), scenario1_D4_contribution), '/', length(scenario1_D4_contribution))

scenario1_D4_avg_contribution_transposed <- scenario1_D4_avg_contribution %>% map(.,~{t(.)})

## contribution of each sub-annual matrix to lambda's sensitivities, matrix S_B's                                     
scenario1_S_B_contribution_4yr <- purrr::map2(scenario1_D4_avg_contribution_transposed, scenario1_A4_avg_sens, `%*%`)
# remove "conv" in all names
scenario1_S_B_contribution_4yr_raw_names <- names( scenario1_S_B_contribution_4yr)

scenario1_S_B_contribution_4yr_names <- gsub('conv.', '', scenario1_S_B_contribution_4yr_raw_names)

names(scenario1_S_B_contribution_4yr) <- scenario1_S_B_contribution_4yr_names
```

```{r scenario1-elasticity-4yr, echo=FALSE}
## calculate elasticity, see p. 121

## NEED NEW NAMES FOR ALL THE LIST
# lambda at scenario1_rotation_wise_lambda 
scenario1_lambda_4yr_conv <- scenario1_annualized_lambda_df_long$annualized_lambda[5]

scenario1_lambda_4yr_low <-scenario1_annualized_lambda_df_long$annualized_lambda[6]
# Elasticity contribution left: check if all_periods_4yr_conv_chain is the appropriate element 
# The right-most matrix of all_periods_4yr_conv_chain is C4_spring_tillage
# why is the order of "all_periods_4yr_conv_chain" and "sens_contribution_4yr" opposite?


scenario1_b_hij_4yr_over_lambda_conv_left <-  scenario1_all_periods_4yr_conv_chain %>%
  map(., ~{./scenario1_lambda_4yr_conv})

scenario1_b_hij_4yr_over_lambda_low_left <-  scenario1_all_periods_4yr_low_chain %>%
  map(., ~{./scenario1_lambda_4yr_low})

# Elasticity contribution right component: S_B's sens_contribution_4yr

# Elasticity
scenario1_E_B_contribution_4yr_conv  <- Map(\(x, y) Reduce(`%*%`, list(x, y)),
                                  scenario1_b_hij_4yr_over_lambda_conv_left ,
                                  scenario1_S_B_contribution_4yr)
## pick out the names
scenario1_E_B_contribution_4yr_conv_raw_names <- names(scenario1_E_B_contribution_4yr_conv )

## rename "means" with "E_B" in list names, for identification

scenario1_E_B_contribution_4yr_conv_names <- gsub('mean', 'E_B', scenario1_E_B_contribution_4yr_conv_raw_names )
## put the names back
names(scenario1_E_B_contribution_4yr_conv ) <- scenario1_E_B_contribution_4yr_conv_names 


scenario1_E_B_contribution_4yr_low  <- Map(\(x, y) Reduce(`%*%`, list(x, y)),
                                 scenario1_b_hij_4yr_over_lambda_low_left,
                                 scenario1_S_B_contribution_4yr)

## pick out the names
scenario1_E_B_contribution_4yr_low_raw_names <- names(scenario1_E_B_contribution_4yr_low)

## rename "means" with "E_B" in list names, for identification

scenario1_E_B_contribution_4yr_low_names <- gsub('mean', 'E_B', scenario1_E_B_contribution_4yr_low_raw_names )
## put the names back
names(scenario1_E_B_contribution_4yr_low ) <- scenario1_E_B_contribution_4yr_low_names 
```



```{r scenario1-S-B-recombine, echo=FALSE}
## Gather S_B contribution lists by sub-annual matrices: all the spring tillage matrices in 6 cropping systems together, all the emergence matrices together, ...

scenario1_S_B_contribution_recombined <- tibble::lst(scenario1_S_B_contribution_2yr, 
                                           scenario1_S_B_contribution_3yr,
                                           scenario1_S_B_contribution_4yr)


## Trim each matrix in the recombined S_B contribution list to the needed n row x 1 column
#https://stackoverflow.com/questions/72326431/extract-the-same-column-from-all-matrices-in-a-nested-list/72326729#72326729

scenario1_S_B_contribution_recombined_first_col <- rapply(scenario1_S_B_contribution_recombined, \(x) x[, 1, drop=FALSE], how='list')

## Transpose the trimmed S_B list

scenario1_S_B_contribution_recombined_first_col_transpose <- rapply(scenario1_S_B_contribution_recombined_first_col, \(x) t(x), how='list')
```


```{r scenario1-phase-wise-lambda, include=FALSE}
scenario1_phase_lambda <-  scenario1_phase_projection_trimmed %>% 
  map(., ~{lambda(.)}) %>%
  unlist(recursive = FALSE) %>%
  data.frame() %>%
  rename(phase_lambda = ".") %>%
  tibble::rownames_to_column() %>%
  mutate(Crop_ID = substr(rowname, 1,2),
         Corn_weed_management = substring(rowname, 4),
         Corn_weed_management = ifelse(Corn_weed_management == "conv", paste0(Corn_weed_management,"entional"), "low"),
         Rotation = paste0(substr(rowname,2,2),"-year")) %>%
  arrange(Rotation, Corn_weed_management) %>%
  mutate(phase_lambda_r = round(phase_lambda, 2))

# View(scenario1_phase_lambda )
```

```{r scenario1-phase-wise-lambda-plot, echo=FALSE, fig.width = 7, fig.height= 7, fig.cap= "Scenario 1: Changes of seed densities in two soil strata after 12 model years in three rotations (2-year, 3-year, and 4-year) crossed with two corn weed management programs (conventional and low herbicide). The model started at year 0 with 1000 and 0 seeds per squared meter in the top (0-2 cm) and bottom (2-20 cm) strata, respectively. The red horizontal line shows the number of seeds in the top stratum at the beginning of the model clock. The annualized population growth rates are followed by their variances in brackets. The model years' are labelled with the main crop species names' abbreviations: C - corn, S - soybean, O - oat, and A - alfalfa."}

scenario1_phase_seed_vectors_long <- scenario1_phase_seed_vectors %>%
  mutate(Stratum = rep(c("0-2 cm", "2-20 cm"),6),
         Rotation = c(rep("2-year",4), rep("3-year",4), rep("4-year",4)),
         Corn_weed_management = rep(c("conventional", "conventional", "low", "low"),3)) %>%
  pivot_longer(!c(Stratum:Corn_weed_management), names_to = "Step", values_to = "Count") %>%
  mutate(Year = as.numeric(substring(Step, 2)),
         Sequence = c(rep(c(" ", "C", "S", "C", "S", "C", "S", "C", "S", "C", "S", "C", "S"),1),
                      rep(" ", 13),
                      rep(c(" ", "C", "S", "C", "S", "C", "S", "C", "S", "C", "S", "C", "S"),1),
                      rep(" ", 13),
                      rep(c(" ", "C", "S", "O", "C", "S", "O", "C", "S", "O", "C", "S", "O"),1),
                      rep(" ", 13),
                       rep(c(" ", "C", "S", "O", "C", "S", "O", "C", "S", "O", "C", "S", "O"),1),
                      rep(" ", 13),
                      rep(c(" ", "C", "S", "O", "A", "C", "S", "O", "A", "C", "S", "O", "A"),1),
                      rep(" ", 13),
                      rep(c(" ", "C", "S", "O", "A", "C", "S", "O", "A", "C", "S", "O", "A"),1),
                      rep(" ", 13)))
 #        Year_Crop = paste(Year, Sequence, sep = "_")) # using "/" as a sep will break the x-axis border later

#View(scenario1_annualized_lambda_df_long)
# View( scenario1_phase_seed_vectors_long)



## customize lambda table for facet annotation
# View(scenario1_annualized_lambda_and_var )
# https://stackoverflow.com/questions/72426613/individual-text-box-with-greek-letter-on-each-facet-grid-panel/72426740#72426740
lambda_label <- data.frame(
  label = c("\u03BB(2,conv) = 0.8 \n \u03BB(C2,conv) = 1.7 \n \u03BB(S2,conv) = 0.5", 
                        "\u03BB(3,low) = 0.9 \n  \u03BB(C3,low) = 1.92 \n \u03BB(S3,low) = 0.5 \n \u03BB(O3,low) = 1.1", 
            "\u03BB(4,conv) = 0.7 \n \u03BB(C4, conv) = 1.3,  \u03BB(S4,conv) = 0.5 \n \u03BB(O4,conv) = 1.5, \u03BB(A4,conv) = 0.5",
            "\u03BB(2,low) = 0.9 \n \u03BB(C2,low) = 2.3 \n \u03BB(S2,low) = 0.5",
            "\u03BB(3,conv) = 0.7 \n  \u03BB(C3,conv) = 0.7 \n \u03BB(S3,conv) = 0.5 \n \u03BB(O3,conv) = 0.8",
            "\u03BB(4,low) = 1.4 \n \u03BB(C4,low) = 28.4, \u03BB(S4,low) = 0.5 \n \u03BB(O4,low) = 2.0, \u03BB(A4,low) = 0.5"),
  Rotation = rep(c("2-year", "3-year", "4-year"), 2),
  Corn_weed_management = rep(c("conventional", "low"), 3),
  Stratum = rep("placeholder", 6) #need this placeholder for the geom_text in the code chain below to run
)

## reverse legend: https://www.geeksforgeeks.org/reversing-the-order-of-a-ggplot2-legend/
scenario1_phase_seed_vectors_long  %>% 
  mutate(ln_Count = log(Count + 1)) %>%
  ggplot() +
   aes(x = Year, y = ln_Count, group = Stratum) +
  geom_line(aes(y = ln_Count, linetype =  Stratum)) +
  geom_point(aes(y = ln_Count, shape =  Stratum)) +
  geom_hline(aes(yintercept = log(1001), color = "baseline")) +
  facet_wrap(Rotation ~ Corn_weed_management, ncol = 2, labeller = label_wrap_gen(multi_line=FALSE)) + 
  scale_x_continuous(breaks = scales::pretty_breaks(n = 13)) + #don't need this with as.factor(Year)
  labs(x = "Crop species abbreviation and model year",   #/
       y = expression(paste("ln(Seed density (seeds+1)",~m^-2,"))"))) +
#  theme(axis.text.x = element_text(angle = 90)) +
  theme(legend.position = "bottom", legend.title = element_blank(),
        legend.key = element_rect(fill = "transparent", colour = "transparent"),
        panel.background=element_rect(fill="transparent",colour=NA),
      plot.background=element_rect(fill="transparent",colour=NA)) +
  #annotate("text", label = paste("\u03BB =", c("0.567 (1663.3)", "0.537 (1876.0)", "0.544 (46598.7)", "0.542 (46996.3)", "0.701 (268.9)", "0.968 (141.3)")) , size = 3, x = 8, y = 10000) +
  ylim(0,16) +
    theme_bw() +
 # guides(shape=guide_legend(title = "soil stratum")) +
  theme(legend.position = "top") +
  geom_text(data = lambda_label, aes(label = label), size = 2.5, x = 4, y = 13) +
      geom_text(aes(x = Year, 
                  y = 16,  #leave space between bar and label
                  label = Sequence), 
              size = 2) +
  guides(colour = "none")
# one layered panel name <https://stackoverflow.com/questions/45699411/facet-label-merging-into-a-single-row-ggplot2>
# none of facet_nested_wrap, or lemon::'s is working
```


```{r scenario1-phase-wise-lambda-plot-no-annotation, echo=FALSE, fig.width = 7, fig.height= 7, fig.cap= "Scenario 1: Changes of seed densities in two soil strata after 12 model years in three rotations (2-year, 3-year, and 4-year) crossed with two corn weed management programs (conventional and low herbicide). The model started at year 0 with 1000 and 0 seeds per squared meter in the top (0-2 cm) and bottom (2-20 cm) strata, respectively. The red horizontal line shows the number of seeds in the top stratum at the beginning of the model clock. The annualized population growth rates are followed by their variances in brackets. The model years' are labelled with the main crop species names' abbreviations: C - corn, S - soybean, O - oat, and A - alfalfa."}

scenario1_phase_seed_vectors_long <- scenario1_phase_seed_vectors %>%
  mutate(Stratum = rep(c("0-2 cm", "2-20 cm"),6),
         Rotation = c(rep("2-year",4), rep("3-year",4), rep("4-year",4)),
         Corn_weed_management = rep(c("conventional", "conventional", "low", "low"),3)) %>%
  pivot_longer(!c(Stratum:Corn_weed_management), names_to = "Step", values_to = "Count") %>%
  mutate(Year = as.numeric(substring(Step, 2)),
         Sequence = c(rep(c(" ", "C", "S", "C", "S", "C", "S", "C", "S", "C", "S", "C", "S"),1),
                      rep(" ", 13),
                      rep(c(" ", "C", "S", "C", "S", "C", "S", "C", "S", "C", "S", "C", "S"),1),
                      rep(" ", 13),
                      rep(c(" ", "C", "S", "O", "C", "S", "O", "C", "S", "O", "C", "S", "O"),1),
                      rep(" ", 13),
                       rep(c(" ", "C", "S", "O", "C", "S", "O", "C", "S", "O", "C", "S", "O"),1),
                      rep(" ", 13),
                      rep(c(" ", "C", "S", "O", "A", "C", "S", "O", "A", "C", "S", "O", "A"),1),
                      rep(" ", 13),
                      rep(c(" ", "C", "S", "O", "A", "C", "S", "O", "A", "C", "S", "O", "A"),1),
                      rep(" ", 13)))
 #        Year_Crop = paste(Year, Sequence, sep = "_")) # using "/" as a sep will break the x-axis border later

#View(scenario1_annualized_lambda_df_long)
# View( scenario1_phase_seed_vectors_long)



## reverse legend: https://www.geeksforgeeks.org/reversing-the-order-of-a-ggplot2-legend/
scenario1_phase_seed_vectors_long  %>% 
  mutate(ln_Count = log(Count + 1)) %>%
  ggplot() +
   aes(x = Year, y = ln_Count, group = Stratum) +
  geom_line(aes(y = ln_Count, linetype =  Stratum)) +
  geom_point(aes(y = ln_Count, shape =  Stratum)) +
  geom_hline(aes(yintercept = log(1001), color = "baseline")) +
  facet_wrap(Rotation ~ Corn_weed_management, ncol = 2, labeller = label_wrap_gen(multi_line=FALSE)) + 
  scale_x_continuous(breaks = scales::pretty_breaks(n = 13)) + #don't need this with as.factor(Year)
  labs(x = "Crop species abbreviation and model year",   #/
       y = expression(paste("ln(Seed density (seeds+1)",~m^-2,"))"))) +
#  theme(axis.text.x = element_text(angle = 90)) +
  theme(legend.position = "bottom", legend.title = element_blank(),
        legend.key = element_rect(fill = "transparent", colour = "transparent"),
        panel.background=element_rect(fill="transparent",colour=NA),
      plot.background=element_rect(fill="transparent",colour=NA)) +
  #annotate("text", label = paste("\u03BB =", c("0.567 (1663.3)", "0.537 (1876.0)", "0.544 (46598.7)", "0.542 (46996.3)", "0.701 (268.9)", "0.968 (141.3)")) , size = 3, x = 8, y = 10000) +
#  ylim(0,16) +
    theme_bw() +
 # guides(shape=guide_legend(title = "soil stratum")) +
  theme(legend.position = "top") +
#  geom_text(data = lambda_label, aes(label = label), size = 2.5, x = 4, y = 13) +
      geom_text(aes(x = Year, 
                  y = 16,  #leave space between bar and label
                  label = Sequence), 
              size = 2) +
  guides(colour = "none")
# one layered panel name <https://stackoverflow.com/questions/45699411/facet-label-merging-into-a-single-row-ggplot2>
# none of facet_nested_wrap, or lemon::'s is working
```

```{r}
```

```{r scenario1-all-E-B, include=FALSE}
scenario1_E_B_contribution <- tibble::lst(scenario1_E_B_contribution_2yr_conv,
                                scenario1_E_B_contribution_2yr_low,
                                scenario1_E_B_contribution_3yr_conv,
                                scenario1_E_B_contribution_3yr_low,
                                scenario1_E_B_contribution_4yr_conv,
                                scenario1_E_B_contribution_4yr_low )


scenario1_E_B_contribution_unlist <- unlist(scenario1_E_B_contribution, recursive = FALSE)

#View(E_B_contribution  )
# Keep non-zeros only 
matrix_trim <- function(x) {
      m1 <- x == 0
      x[!(rowSums(m1)== ncol(m1)), 
      !(colSums(m1) == nrow(m1)),drop = FALSE]
}

#scenario1_E_B_contribution_trimmed  <- rapply(scenario1_E_B_contribution,\(x) matrix_trim(x), how='list')


#rapply(scenario1_E_B_contribution_trimmed ,\(x) round(x,3),how='list')

```



```{r scenario1-E-B-spring-till, echo=FALSE}
scenario1_E_B_spring_tillage <-  scenario1_E_B_contribution_unlist[str_detect(names(scenario1_E_B_contribution_unlist), "spring")]

# View( scenario1_E_B_spring_tillage )

# relevant number: the first row from column 3 to 8
# The non-zeros in (1,1) and (1,2) and row 2 are remnants from how the 
scenario1_E_B_spring_tillage_trimmed <-  rapply(scenario1_E_B_spring_tillage,\(x) matrix_trim(x), how='list') #View( E_B_spring_tillage_trimmed )

#convert matrix to vector, the vector was binded by column (column 2 after column 1) 
scenario1_E_B_spring_tillage_vector <- rapply(scenario1_E_B_spring_tillage_trimmed,\(x) c(x), how='list') 
# View(E_B_spring_tillage_vector )

## Separate spring tillage E_B by corn weed management to manage the rowname string 
scenario1_E_B_spring_tillage_conv <- scenario1_E_B_spring_tillage_vector[str_detect(names(scenario1_E_B_spring_tillage_vector), "conv")]

scenario1_E_B_spring_tillage_low <- scenario1_E_B_spring_tillage_vector[str_detect(names(scenario1_E_B_spring_tillage_vector), "low")]

scenario1_E_B_spring_tillage_conv_unlist <- scenario1_E_B_spring_tillage_conv %>% 
  unlist(., recursive = FALSE) %>% 
  data.frame(fix.empty.names = TRUE) %>% 
  rename(E_B_ij = ".") %>%
  tibble::rownames_to_column() %>%
  mutate(Crop_ID = substr(rowname, 37, 38),
         Corn_weed_management = substr(rowname, 40, 43),
         group = substring(rowname, 49),
         Crop = substr(rowname, 37, 37),
          Rotation = paste0(substr(rowname, 28, 28),"-year")) %>%
  mutate(element_ij = ifelse(endsWith(group, "1"), "t_11_s",
                             ifelse(endsWith(group, "2"), "t_21_s",
                                    ifelse(endsWith(group, "3"), "t_12_s", "t_22_s"))))
  
# View( scenario1_E_B_spring_tillage_conv_unlist )
# st_ij: spring tillage induced seed movement from strata i (top) to j (bottom)
scenario1_E_B_spring_tillage_low_unlist <- scenario1_E_B_spring_tillage_low %>% 
  unlist(., recursive = FALSE) %>% 
  data.frame(fix.empty.names = TRUE) %>% 
  rename(E_B_ij = ".") %>%
  tibble::rownames_to_column() %>%
  mutate(Crop_ID = substr(rowname, 36, 37),
         Corn_weed_management = substr(rowname, 39, 41),
         group = substring(rowname, 48),
         Crop = substr(rowname, 36, 36),
          Rotation = paste0(substr(rowname, 28, 28),"-year")) %>%
  mutate(element_ij = ifelse(endsWith(group, "1"), "t_11_s",
                             ifelse(endsWith(group, "2"), "t_21_s",
                                    ifelse(endsWith(group, "3"), "t_12_s", "t_22_s"))))


# View( scenario1_E_B_spring_tillage_low_unlist)

# recombine conv and low 
scenario1_E_B_spring_tillage_recombine <- rbind(scenario1_E_B_spring_tillage_conv_unlist, scenario1_E_B_spring_tillage_low_unlist)
#View(scenario1_E_B_spring_tillage_recombine)


scenario1_E_B_spring_tillage_recombine_wide <- scenario1_E_B_spring_tillage_recombine %>%
  select(!c(rowname, group)) %>% 
  pivot_wider(names_from = element_ij, values_from = E_B_ij) %>%
  mutate(Scenario = 1) %>%
  select(Scenario, Rotation, Crop, Crop_ID, Corn_weed_management, t_11_s:t_22_s) %>%
  mutate(Order = ifelse(Crop == "C", 1,
                        ifelse(Crop == "S", 2,
                               ifelse(Crop == "O", 3, 4))))%>%
  arrange(Rotation, Order, Corn_weed_management) %>%
  select(!c(Order, Crop)) 

#View( scenario1_E_B_spring_tillage_recombine_wide )

```

```{r scenario1-E-B-emerge, echo=FALSE}
scenario1_E_B_emerge <-  scenario1_E_B_contribution_unlist[str_detect(names(scenario1_E_B_contribution_unlist), "emerge")]

# View(scenario1_E_B_emerge)

# relevant number: the first row from column 3 to 8; in reality, bottom seeds do not germinate
scenario1_E_B_emerge_trimmed <-  rapply(scenario1_E_B_emerge,\(x) x[1,], how='list')
# View( E_B_emerge_trimmed )


## Separate spring tillage E_B by corn weed management to manage the rowname string 
scenario1_E_B_emerge_conv <- scenario1_E_B_emerge_trimmed[str_detect(names(scenario1_E_B_emerge_trimmed), "conv")]

scenario1_E_B_emerge_low <- scenario1_E_B_emerge_trimmed[str_detect(names(scenario1_E_B_emerge_trimmed ), "low")]

scenario1_E_B_emerge_conv_unlist <- scenario1_E_B_emerge_conv %>% 
  unlist(., recursive = FALSE) %>% 
  data.frame(fix.empty.names = TRUE) %>% 
  rename(E_B_ij = ".") %>%
  tibble::rownames_to_column() %>%
  mutate(Crop_ID = substr(rowname, 37, 38),
         Corn_weed_management = substr(rowname, 32, 35),
         group = substring(rowname, 69),
         Crop = substr(rowname, 37, 37),
         Rotation = paste0(substr(rowname, 28, 28),"-year")) 
  
# View( scenario1_E_B_emerge_conv_unlist)

scenario1_E_B_emerge_low_unlist <- scenario1_E_B_emerge_low %>% 
  unlist(., recursive = FALSE) %>% 
  data.frame(fix.empty.names = TRUE) %>% 
  rename(E_B_ij = ".") %>%
  tibble::rownames_to_column() %>%
  mutate(Crop_ID = substr(rowname, 36, 37),
         Corn_weed_management = substr(rowname, 32, 34),
         group = substring(rowname, 67),
         Crop = substr(rowname, 37, 37),
         Rotation = paste0(substr(rowname, 28, 28),"-year")) 
# View( scenario1_E_B_emerge_low_unlist)

# recombine conv and low 
scenario1_E_B_emerge_recombine <- rbind(scenario1_E_B_emerge_conv_unlist, scenario1_E_B_emerge_low_unlist)
#View(scenario1_E_B_emerge_recombine)


scenario1_E_B_emerge_recombine_wide <- scenario1_E_B_emerge_recombine %>%
  select(!rowname) %>% 
  pivot_wider(names_from = group, values_from = E_B_ij) %>%
  mutate(Scenario = 1)  %>%
  select(Scenario, Rotation, Crop, Crop_ID, Corn_weed_management, s_t:p_co_6) %>%
  mutate(Order = ifelse(Crop == "C", 1,
                        ifelse(Crop == "S", 2,
                               ifelse(Crop == "O", 3, 4))))%>%
  arrange(Rotation, Order, Corn_weed_management) %>%
  select(!c(Order, Crop, s_b)) %>% #keep the relevant columns only 
 #  mutate_at(5:11, round, 2) %>%
  rename("d" = s_t,
        "g_1" = p_co_1,
        "g_2" = p_co_2,
        "g_3" = p_co_3,
        "g_4" = p_co_4,
        "g_5" = p_co_5,
        "g_6" = p_co_6)

#View(scenario1_E_B_emerge_recombine_wide) 
```

```{r scenario1-E-B-summer, echo=FALSE}
scenario1_E_B_summer <-  scenario1_E_B_contribution_unlist[str_detect(names(scenario1_E_B_contribution_unlist), "summer")]

# relevant numbers: the diagonal 
# off diagonal elements  were remnants
scenario1_E_B_summer_diag <-  rapply(scenario1_E_B_summer,\(x) diag(x), how='list')
# View( E_B_summer_diag)

## Separate seedling survival E_B by corn weed management to manage the rowname string 
scenario1_E_B_summer_conv <- scenario1_E_B_summer_diag[str_detect(names(scenario1_E_B_summer_diag), "conv")]

scenario1_E_B_summer_low <- scenario1_E_B_summer_diag[str_detect(names(scenario1_E_B_summer_diag), "low")]


scenario1_E_B_summer_conv_unlist <- scenario1_E_B_summer_conv %>% 
  unlist(., recursive = FALSE) %>% 
  data.frame(fix.empty.names = TRUE) %>% 
  rename(E_B_ij = ".") %>%
  tibble::rownames_to_column() %>%
  mutate(Crop_ID = substr(rowname, 37, 38),
         Corn_weed_management = substr(rowname, 32, 35),
         group = substring(rowname, 75),
         Crop = substr(rowname, 37, 37),
          Rotation = paste0(substr(rowname, 28, 28),"-year")) 

#  View(scenario1_E_B_summer_conv_unlist)  

scenario1_E_B_summer_low_unlist <- scenario1_E_B_summer_low %>% 
  unlist(., recursive = FALSE) %>% 
  data.frame(fix.empty.names = TRUE) %>% 
  rename(E_B_ij = ".") %>%
  tibble::rownames_to_column() %>%
 mutate(Crop_ID = substr(rowname, 36, 37),
         Corn_weed_management = substr(rowname, 32, 34),
         group = substring(rowname, 73),
         Crop = substr(rowname, 36, 36),
          Rotation = paste0(substr(rowname, 28, 28),"-year")) 

# View( scenario1_E_B_summer_low_unlist)

# recombine summer plant survival conv and low 
scenario1_E_B_summer_recombine <- rbind(scenario1_E_B_summer_conv_unlist, scenario1_E_B_summer_low_unlist )

scenario1_E_B_summer_recombine_wide <- scenario1_E_B_summer_recombine %>%
  select(!rowname) %>% 
  pivot_wider(names_from = group, values_from = E_B_ij) %>%
  mutate(Scenario = 1) %>%
  select(Scenario,  Rotation, Crop, Crop_ID, Corn_weed_management, s_t:p_co_6) %>%
  mutate(Order = ifelse(Crop == "C", 1,
                        ifelse(Crop == "S", 2,
                               ifelse(Crop == "O", 3, 4)))) %>%
  arrange(Rotation, Order, Corn_weed_management) %>%
  select(!c(Order, Crop)) %>% 
  #  mutate_at(5:12, round, 2)  %>%
  rename("s_s1" = s_t,
         "s_s2" = s_b,
        "s_p1" = p_co_1,
        "s_p2" = p_co_2,
        "s_p3" = p_co_3,
       "s_p4" = p_co_4,
        "s_p5" = p_co_5,
        "s_p6" = p_co_6)


#View(scenario1_E_B_summer_recombine_wide) 
```


```{r scenario1-E-B-fecund, echo=FALSE}
scenario1_E_B_fecund <-  scenario1_E_B_contribution_unlist[str_detect(names(scenario1_E_B_contribution_unlist), "fecund")]

# relevant number: the first row from column 3 to 8
# The non-zeros in (1,1) and (1,2) and row 2 are remnants from how the 
scenario1_E_B_fecund_trimmed <-  rapply(scenario1_E_B_fecund,\(x) x[1,], how='list')


## Separate fecundity E_B by corn weed management to manage the rowname string 
scenario1_E_B_fecund_conv <- scenario1_E_B_fecund_trimmed[str_detect(names(scenario1_E_B_fecund_trimmed), "conv")]

scenario1_E_B_fecund_low <- scenario1_E_B_fecund_trimmed[str_detect(names(scenario1_E_B_fecund_trimmed), "low")]

scenario1_E_B_fecund_conv_unlist <- scenario1_E_B_fecund_conv %>% 
  unlist(., recursive = FALSE) %>% 
  data.frame(fix.empty.names = TRUE) %>% 
  rename(E_B_ij = ".") %>%
  tibble::rownames_to_column() %>%
  mutate(Crop_ID = substr(rowname, 37, 38),
         Corn_weed_management = substr(rowname, 32, 35),
         group = substring(rowname, 74),
         Crop = substr(rowname, 37, 37),
         Rotation = paste0(substr(rowname, 28, 28),"-year"))  %>%
  filter(group != c("s_t", "s_b")) # keep the relevant numbers only 

# View(scenario1_E_B_fecund_conv_unlist)
scenario1_E_B_fecund_low_unlist <- scenario1_E_B_fecund_low %>% 
  unlist(., recursive = FALSE) %>% 
  data.frame(fix.empty.names = TRUE) %>% 
  rename(E_B_ij = ".") %>%
  tibble::rownames_to_column() %>%
  mutate(Crop_ID = substr(rowname, 36, 37),
         Corn_weed_management = substr(rowname, 32, 34),
         group = substring(rowname, 72),
         Crop = substr(rowname, 36, 36),
         Rotation = paste0(substr(rowname, 28, 28),"-year"))  %>%
  filter(group != c("s_t", "s_b")) # keep the relevant numbers only 

# recombine conv and low 
scenario1_E_B_fecund_recombine <- rbind(scenario1_E_B_fecund_conv_unlist, scenario1_E_B_fecund_low_unlist)

scenario1_E_B_fecund_recombine_wide <- scenario1_E_B_fecund_recombine %>%
  select(!rowname) %>% 
  pivot_wider(names_from = group, values_from = E_B_ij) %>%
  mutate(Scenario = 1) %>%
  select(Scenario, Rotation, Crop, Crop_ID, Corn_weed_management, p_co_1:p_co_6) %>%
  mutate(Order = ifelse(Crop == "C", 1,
                        ifelse(Crop == "S", 2,
                               ifelse(Crop == "O", 3, 4)))) %>%
  arrange(Rotation, Order, Corn_weed_management) %>%
  select(!c(Order, Crop))  %>%
#   mutate_at(5:10, round, 2)  %>%
  rename("f_1" = p_co_1,
        "f_2"= p_co_2,
        "f_3" = p_co_3,
        "f_4" = p_co_4,
        "f_5" = p_co_5,
        "f_6" = p_co_6)

#View(scenario1_E_B_fecund_recombine_wide)
```


```{r scenario1-E-B-postharvest-till, echo=FALSE}
scenario1_E_B_postharvest_tillage <-  scenario1_E_B_contribution_unlist[str_detect(names(scenario1_E_B_contribution_unlist), "harvest")]

# View( scenario1_E_B_postharvest_tillage )

# relevant number: the first row from column 3 to 8
# The non-zeros in (1,1) and (1,2) and row 2 are remnants from how the 
scenario1_E_B_postharvest_tillage_trimmed <-  rapply(scenario1_E_B_postharvest_tillage,\(x) matrix_trim(x), how='list')
# View( scenario1_E_B_postharvest_tillage_trimmed )

#convert matrix to vector, the vector was binded by column (column 2 after column 1) 
scenario1_E_B_postharvest_tillage_vector <- rapply(scenario1_E_B_postharvest_tillage_trimmed,\(x) c(x), how='list') 
# View(scenario1_E_B_postharvest_tillage_vector )

## Separate spring tillage E_B by corn weed management to manage the rowname string 
scenario1_E_B_postharvest_tillage_conv <- scenario1_E_B_postharvest_tillage_vector[str_detect(names(scenario1_E_B_postharvest_tillage_vector), "conv")]

scenario1_E_B_postharvest_tillage_low <- scenario1_E_B_postharvest_tillage_vector[str_detect(names(scenario1_E_B_postharvest_tillage_vector), "low")]

#View( scenario1_E_B_postharvest_tillage_low )
scenario1_E_B_postharvest_tillage_conv_unlist <- scenario1_E_B_postharvest_tillage_conv %>% 
  unlist(., recursive = FALSE) %>% 
  data.frame(fix.empty.names = TRUE) %>% 
  rename(E_B_ij = ".") %>%
  tibble::rownames_to_column() %>%
  mutate(Crop_ID = substr(rowname, 37, 38),
         Corn_weed_management = substr(rowname, 32, 35),
         group = substring(rowname, 49),
         Crop = substr(rowname, 37, 37),
         Rotation = paste0(substr(rowname, 28, 28),"-year"))  %>%
  mutate(element_ij = ifelse(endsWith(group, "1"), "t_11_f",
                             ifelse(endsWith(group, "2"), "t_21_f",
                                    ifelse(endsWith(group, "3"), "t_12_f", "t_22_f"))))
  
# View( scenario1_E_B_postharvest_tillage_conv_unlist)
scenario1_E_B_postharvest_tillage_low_unlist <- scenario1_E_B_postharvest_tillage_low %>% 
  unlist(., recursive = FALSE) %>% 
  data.frame(fix.empty.names = TRUE) %>% 
  rename(E_B_ij = ".") %>%
  tibble::rownames_to_column() %>%
   mutate(Crop_ID = substr(rowname, 36, 37),
         Corn_weed_management = substr(rowname, 32, 34),
         group = substring(rowname, 47),
         Crop = substr(rowname, 36, 36),
         Rotation = paste0(substr(rowname, 28, 28),"-year"))  %>%
  mutate(element_ij = ifelse(endsWith(group, "1"), "t_11_f",
                             ifelse(endsWith(group, "2"), "t_21_f",
                                    ifelse(endsWith(group, "3"), "t_12_f", "t_22_f"))))

# View( scenario1_E_B_postharvest_tillage_low_unlist)

# recombine conv and low 
scenario1_E_B_postharvest_tillage_recombine <- rbind(scenario1_E_B_postharvest_tillage_conv_unlist, scenario1_E_B_postharvest_tillage_low_unlist)
#View(scenario1_E_B_postharvest_tillage_recombine)


scenario1_E_B_postharvest_tillage_recombine_wide <- scenario1_E_B_postharvest_tillage_recombine %>%
  select(!c(rowname, group)) %>% 
  pivot_wider(names_from = element_ij, values_from = E_B_ij) %>%
  mutate(Parameter = "post-harvest tillage", 
         Scenario = 1) %>%
  select(Scenario, Rotation, Crop, Crop_ID, Corn_weed_management, t_11_f:t_22_f) %>%
  mutate(Order = ifelse(Crop == "C", 1,
                        ifelse(Crop == "S", 2,
                               ifelse(Crop == "O", 3, 4))))%>%
  arrange(Rotation, Order, Corn_weed_management) %>%
  select(!c(Order, Crop)) 

# View(scenario1_E_B_postharvest_tillage_recombine_wide)
```


```{r scenario1-E-B-overwinter, echo=FALSE}
scenario1_E_B_overwinter <-  scenario1_E_B_contribution_unlist[str_detect(names(scenario1_E_B_contribution_unlist), "overwinter")]

#View( scenario1_scenario1_E_B_overwinter )

# relevant number: the first row from column 3 to 8
# The non-zeros in (1,1) and (1,2) and row 2 are remnants from how the 
scenario1_E_B_overwinter_trimmed <-  rapply(scenario1_E_B_overwinter,\(x) matrix_trim(x), how='list')
#View( scenario1_E_B_overwinter_trimmed )

#keep the diagonal only 
scenario1_E_B_overwinter_vector <- rapply(scenario1_E_B_overwinter_trimmed,\(x) diag(x), how='list') 
#View(scenario1_E_B_overwinter_vector )

## Separate spring tillage E_B by corn weed management to manage the rowname string 
scenario1_E_B_overwinter_conv <- scenario1_E_B_overwinter_vector[str_detect(names(scenario1_E_B_overwinter_vector), "conv")]

scenario1_E_B_overwinter_low <- scenario1_E_B_overwinter_vector[str_detect(names(scenario1_E_B_overwinter_vector), "low")]

scenario1_E_B_overwinter_conv_unlist <- scenario1_E_B_overwinter_conv %>% 
  unlist(., recursive = FALSE) %>% 
  data.frame(fix.empty.names = TRUE) %>% 
  rename(E_B_ij = ".") %>%
  tibble::rownames_to_column() %>%
  mutate(Crop_ID = substr(rowname, 37, 38),
         Corn_weed_management = substr(rowname, 32, 35),
         group = substring(rowname, 70),
         Crop = substr(rowname, 37, 37),
         Rotation = paste0(substr(rowname, 28, 28),"-year"))  
  
# View( scenario1_E_B_overwinter_conv_unlist)
scenario1_E_B_overwinter_low_unlist <- scenario1_E_B_overwinter_low %>% 
  unlist(., recursive = FALSE) %>% 
  data.frame(fix.empty.names = TRUE) %>% 
  rename(E_B_ij = ".") %>%
  tibble::rownames_to_column() %>%
   mutate(Crop_ID = substr(rowname, 36, 37),
         Corn_weed_management = substr(rowname, 32, 34),
         group = substring(rowname, 68),
         Crop = substr(rowname, 36, 36),
         Rotation = paste0(substr(rowname, 28, 28),"-year"))  

#View( scenario1_E_B_overwinter_low_unlist)

# recombine conv and low 
scenario1_E_B_overwinter_recombine <- rbind(scenario1_E_B_overwinter_conv_unlist, scenario1_E_B_overwinter_low_unlist)
#View(scenario1_E_B_overwinter_recombine)

#so stand for survival overwinter
scenario1_E_B_overwinter_recombine_wide <- scenario1_E_B_overwinter_recombine %>%
  select(!rowname) %>% 
  pivot_wider(names_from = group, values_from = E_B_ij) %>%
  mutate(Scenario = 1) %>%
  select(Scenario, Rotation, Crop, Crop_ID, Corn_weed_management, s_t, s_b) %>%
  mutate(Order = ifelse(Crop == "C", 1,
                        ifelse(Crop == "S", 2,
                               ifelse(Crop == "O", 3, 4))))%>%
  arrange(Rotation, Order, Corn_weed_management) %>%
  select(!c(Order, Crop)) %>%
#   mutate_at(5:6, round, 2)  %>%
  rename("o_11" = s_t,
         "o_22"= s_b)

# View(scenario1_E_B_overwinter_recombine_wide)
```

```{r scenario1-E-B-by-rot, echo=FALSE, warning=FALSE, message=FALSE}
## Recombine all the E-B tables
scenario1_E_B_recombine_wide <- plyr::join_all(list(scenario1_E_B_spring_tillage_recombine_wide,
            scenario1_E_B_emerge_recombine_wide,
            scenario1_E_B_summer_recombine_wide,
            scenario1_E_B_fecund_recombine_wide,
            scenario1_E_B_postharvest_tillage_recombine_wide,
            scenario1_E_B_overwinter_recombine_wide), by = c("Scenario", "Rotation", "Crop_ID", "Corn_weed_management"), type='left')  %>% select(!Scenario) %>%
  mutate(Corn_weed_management = ifelse(Corn_weed_management == "conv", paste0(Corn_weed_management,"entional"), "low"),
         Crop_a = substr(Crop_ID,1,1),
         Crop = ifelse(Crop_a == "C", "corn",
                       ifelse(Crop_a == "S", "soybean",
                              ifelse(Crop_a == "O", "oat", "alfalfa")))) 

# View( scenario1_E_B_recombine_wide )


# extract ranking of each parameter on elasticity of lambda by each crop ID x corn weed management 
# ties are assigned the same ranks
# higher rank = higher value (counter-intuitive but the bar height will make sense in the scenario2-E-B-by-rot-rank chunk) 
scenario1_E_B_recombine_wide_ranked <- data.frame(scenario1_E_B_recombine_wide[,c(1:3,35,36)],
           t(apply(scenario1_E_B_recombine_wide[,-c(1:3,35,36)], 1, 
                   rank, ties.method='min')))
```



```{r scenario1-E-B-by-rot-rank, include = FALSE,  fig.cap = "Scenario 1: Elasticity of annualized population growth rates to changes in lower-level demographic parameters. Bar height represents parameter's ranking. Each bar is labeled with the absolute value of the contribution of the parameter to elasticity of annualized population growth rates (zeros from s_s1 through s_p6 in C3, S3, and O3 were due to rounding). Crop identities are color-coded by crop species. From left to right of the x-axis, the sub-annual demographic parameters are: t_11_s - probability that a seed in the 0-2 cm soil stratum stay at that statum after pre-planting tillage; t_21_s - probability that a seed in the 2-20 cm soil stratum move to the 0-2 cm soil stratum after pre-planting tillage; t_12_s - probability that a seed in the 0-2 cm soil stratum move to the 2-20 cm stratum after pre-planting tillage; and t_22_s - probability that a seed in the 2-20 cm soil stratum stay at that statum after pre-planting tillage; d - the probability that a seed is not germinating; g_1 through g_6: the probabiblites that a seed emerge to seedling cohorts 1 through 6; s_s1 and s_s2 - the survival rate of seeds in the 0-2 cm and 2-20 cm soil strata in the cropped season; s_p1 through s_p6: the probability that seedling cohorts 1 through 6 reach reproductive maturity; f_1 through f_6 - the fecundity rates of mature plant cohorts 1 through 6; t_11_f - probability that a seed in the 0-2 cm soil stratum stay at that statum after post-harvest tillage; t_21_f - probability that a seed in the 2-20 cm soil stratum move to the 0-2 cm soil stratum after post-harvest tillage; t_12_f - probability that a seed in the 0-2 cm soil stratum move to the 2-20 cm stratum after post-harvest tillage; and t_22_f - probability that a seed in the 2-20 cm soil stratum stay at that statum after post-harvest tillage; o_11 and o_12 - overwiter survival rates in the 0-2 cm and 2-20 cm soil strata.", fig.height= 16, fig.width=12 , message=FALSE, warning=FALSE}
## Prepare bar labels (with absolute values of E_B)

scenario1_E_B_recombine_long <- scenario1_E_B_recombine_wide %>%
  select(!Crop_a) %>%
  pivot_longer(!c(Rotation,Crop,Crop_ID, Corn_weed_management), names_to = "Parameter", values_to = "Value")


scenario1_E_B_recombine_ranked_long <- scenario1_E_B_recombine_wide_ranked %>%
    select(!Crop_a) %>%
  pivot_longer(!c(Rotation:Crop), names_to = "Parameter", values_to = "Rank") 

scenario1_E_B_recombine_ranked_value <- scenario1_E_B_recombine_ranked_long %>% 
  left_join(scenario1_E_B_recombine_long)  %>%
  mutate(Value_rounded = as.character(round(Value,2)),
         ln_Value = log(Value),
         ln_Value_rounded = as.character(round(ln_Value, 2)))

### Order factors before ggplot2,
## ordering anywhere before this point will be neglected
scenario1_E_B_recombine_ranked_value$Parameter <- factor(scenario1_E_B_recombine_ranked_value$Parameter,
                                levels = c("t_11_s", "t_21_s", "t_12_s", "t_22_s", 
                                           "d", "g_1", "g_2", "g_3", "g_4", "g_5", "g_6",
                                           "s_s1", "s_s2", "s_p1", "s_p2", "s_p3", "s_p4", "s_p5", "s_p6",
                                           "f_1", "f_2", "f_3", "f_4", "f_5", "f_6",
                                           "t_11_f", "t_21_f", "t_12_f", "t_22_f",
                                           "o_11", "o_22"))

## assign orders of Crop_ID by their sequence in each rotation

scenario1_E_B_recombine_ranked_value$Crop_ID <- factor(scenario1_E_B_recombine_ranked_value$Crop_ID,
                                levels = c("C2", "S2", 
                                           "C3", "S3", "O3",
                                           "C4", "S4", "O4", "A4"))



scenario1_E_B_recombine_ranked_value$Crop <- factor(scenario1_E_B_recombine_ranked_value$Crop,
                                levels = c("corn", "soybean", "oat", "alfalfa"))

scenario1_E_B_recombine_ranked_value %>%
ggplot(aes(x=Parameter, y=Rank, fill = Crop)) +
  geom_bar(stat = "identity") +
    scale_fill_brewer(palette = "Set1") +
    geom_text(aes(x = Parameter, 
                  y = 40,  #leave space between bar and label
                  label = Value_rounded), 
              angle = 90,
              size = 2.5) +
  facet_grid(Crop_ID ~ Corn_weed_management) +
  ylim(0, 70) +
  labs(x = "Parameter",
       y= expression(paste("Elasticity of ", lambda, " to changes in lower-level demographic parameters"))) +
  theme(axis.text.x = element_text(angle = 45)) +
  theme(legend.position = "bottom", 
        legend.title = element_blank()) 
```


