---
output:
    bookdown::word_document2:
      toc: false
      fig_caption: yes
    reference_docx: style_template.docx
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(purrr) # for map2()
library(pracma)
library(popbio)
library(tidyverse)
library(magrittr) 
# convert this Rmd to R to source it in results.Rmd
library(flextable)
source("functions.R")
```


```{r scenario1-periodic-matrices-phases-mean-and-var, include=FALSE}
## Summary: everything the same in all scenarios, but:
# mean_emergence:
# summer survival: literature
# Fecundity: 2019
# Overwinter survival: Sosnoskie et al. AMAPA

## Pre-planting tillage 
mean_spring_tillage <-  readRDS("../2-Data/Clean/mean-pre-planting-tillage.RData")
var_spring_tillage <-  readRDS("../2-Data/Clean/var-pre-planting-tillage.RData")

## Emergence 
scenario1_mean_emergence <- readRDS("../2-Data/Clean/mean-emergence-prop-scenario1.RData")
scenario1_var_emergence <- readRDS("../2-Data/Clean/var-emergence-prop-scenario1.RData")

## Seed survival and plant survival 
#### seed survival 

scenario1_mean_summer_seed_survival <- readRDS("../2-Data/Clean/mean-summer-seed-survival-scenario1.RData")
scenario1_var_summer_seed_survival  <- readRDS("../2-Data/Clean/var-summer-seed-survival-scenario1.RData")

#### plant survival: literature data - named as scenario2, because scenario1 is the point-estimates from the experiment 
#female_survival <- readRDS("../2-Data/Clean/female-survival-rate-cohort-equal.RData")

scenario1_mean_female_survival <- readRDS("../2-Data/Clean/mean-summer-seedling-survival-scenario2.RData")
scenario1_var_female_survival <- readRDS("../2-Data/Clean/var-summer-seedling-survival-scenario2.RData")

#### combine seed and plant survivals into one matrix with element-wise multiplication: this is not computing, but arranging using 1's as placeholders 
scenario1_mean_summer_survival <- purrr::map2(scenario1_mean_summer_seed_survival, scenario1_mean_female_survival, `*`)

scenario1_var_summer_survival <- purrr::map2(scenario1_var_summer_seed_survival, scenario1_var_female_survival, `*`)

## Fecundity: next chunk

## Post-harvest tillage
mean_post_harvest_tillage <- readRDS("../2-Data/Clean/mean-post-harvest-tillage.RData")
var_post_harvest_tillage <- readRDS("../2-Data/Clean/var-post-harvest-tillage.RData")

## Overwinter survival 
scenario1_mean_overwinter <- readRDS("../2-Data/Clean/mean-winter-seed-survival-scenario1.RData")
scenario1_var_overwinter <- readRDS("../2-Data/Clean/var-winter-seed-survival-scenario1.RData")
```

```{r scenario1-phase-wise-projection-1, include=FALSE}
## Circle starts at spring tillage Fecundity scenario 1 - 2019 rates
scenario1_mean_fecundity_2019 <- readRDS("../2-Data/Clean/mean-fecundity-19-cohort.RData")

scenario1_var_fecundity_2019 <- readRDS("../2-Data/Clean/var-fecundity-19-cohort.RData")

scenario1_projection_by_matrix_id <- tibble::lst(scenario1_mean_overwinter,
                                                 mean_post_harvest_tillage,
                                                 scenario1_mean_fecundity_2019,
                                                 scenario1_mean_summer_survival,
                                               scenario1_mean_emergence,
                                               mean_spring_tillage)
## name column and row 
scenario1_projection_by_matrix_id_named <- rapply(scenario1_projection_by_matrix_id, 
                                                  function(x) {dimnames(x) <- rep(list(c("seed_top",
                                                                                        "seed_bottom", 
                                                                                        "plant_cohort_1",
                                                                                        "plant_cohort_2",
                                                                                        "plant_cohort_3",
                                                                                        "plant_cohort_4",
                                                                                        "plant_cohort_5",
                                                                                        "plant_cohort_6")),2); x}, how="list")

# View(scenario1_projection_by_matrix_id_named )

## List all periodic matrices within the same crop ID together  
scenario1_projection_by_matrix_id_transpose <- purrr::transpose(scenario1_projection_by_matrix_id_named )

# multiply all the periodic matrices within a crop ID 

scenario1_phase_projection <- scenario1_projection_by_matrix_id_transpose  %>%
  map(., ~{Reduce( "%*%", .)}) 

# check 
#lapply(scenario1_projection_by_matrix_id_transpose, 
#       \(x) x[[1]] %*% x[[2]] %*% x[[3]] %*% x[[4]] %*% x[[5]] %*% x[[6]])

# View(scenario1_phase_projection)
```


```{r scenario1-rotation-group, include=FALSE}
## Separate scenario1_phase_projection by rotation x corn weed management 
# Phases are listed right to left, which is the opposite to their orders 
#2year, conventional
scenario1_rotation_wise_2yr_conv <- scenario1_phase_projection[c("S2_conv", "C2_conv")] #View(scenario1_rotation_wise_2yr_conv)

#2year, low
scenario1_rotation_wise_2yr_low <- scenario1_phase_projection[c("S2_low","C2_low")]
#3-year, conventional
scenario1_rotation_wise_3yr_conv <- scenario1_phase_projection[c("O3_conv", "S3_conv", "C3_conv")]
#View(scenario1_rotation_wise_3yr_conv)

#3-year, low
scenario1_rotation_wise_3yr_low <- scenario1_phase_projection[c("O3_low", "S3_low", "C3_low")]

scenario1_rotation_wise_4yr_conv <- scenario1_phase_projection[c("A4_conv", "O4_conv", "S4_conv", "C4_conv")]

#4-year, low
scenario1_rotation_wise_4yr_low <- scenario1_phase_projection[c("A4_low", "O4_low", "S4_low", "C4_low")]
```


```{r scenario1-phase-wise-lambda-plot-prep, echo=FALSE}
## trim off the trailing zeros 
scenario1_phase_projection_trimmed <- rapply(scenario1_phase_projection, \(x) matrix_trim(x), how = "list")


# View(scenario1_phase_projection_trimmed)

## For all cropping systems, start with the same N0
N0 <- matrix(c(1000,0),nrow = 2)

##Split scenario1_phase_projection_trimmed into 18 data
for (i in seq_along(scenario1_phase_projection_trimmed)) {
    assign(names(scenario1_phase_projection_trimmed)[i], scenario1_phase_projection_trimmed[[i]], .GlobalEnv)
}

## Calculate population after each crop phase, for 12 year
## 2 year, conv
col_names <- c("N0", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "N8", "N9", "N10", "N11", "N12")
### 2-year conv
scenario1_N2yr_conv <- data.frame(matrix(ncol = 13, nrow = 2))
names(scenario1_N2yr_conv ) <- col_names 
scenario1_N2yr_conv$N0 <- N0
scenario1_N2yr_conv$N1 <- C2_conv %*% N0 
scenario1_N2yr_conv$N2 <- S2_conv %*% scenario1_N2yr_conv$N1
scenario1_N2yr_conv$N3 <- C2_conv %*% scenario1_N2yr_conv$N2 
scenario1_N2yr_conv$N4 <- S2_conv %*% scenario1_N2yr_conv$N3 
scenario1_N2yr_conv$N5 <- C2_conv %*% scenario1_N2yr_conv$N4 
scenario1_N2yr_conv$N6 <- S2_conv %*% scenario1_N2yr_conv$N5 
scenario1_N2yr_conv$N7 <- C2_conv %*% scenario1_N2yr_conv$N6 
scenario1_N2yr_conv$N8 <- S2_conv %*% scenario1_N2yr_conv$N7 
scenario1_N2yr_conv$N9 <- C2_conv %*% scenario1_N2yr_conv$N8 
scenario1_N2yr_conv$N10 <- S2_conv %*% scenario1_N2yr_conv$N9 
scenario1_N2yr_conv$N11 <- C2_conv %*% scenario1_N2yr_conv$N10 
scenario1_N2yr_conv$N12 <- S2_conv %*% scenario1_N2yr_conv$N11 

### 2-year low
scenario1_N2yr_low <- data.frame(matrix(ncol = 13, nrow = 2))
names(scenario1_N2yr_low ) <- col_names 
scenario1_N2yr_low$N0 <- N0
scenario1_N2yr_low$N1 <- C2_low %*% N0 
scenario1_N2yr_low$N2 <- S2_low %*% scenario1_N2yr_low$N1
scenario1_N2yr_low$N3 <- C2_low %*% scenario1_N2yr_low$N2 
scenario1_N2yr_low$N4 <- S2_low %*% scenario1_N2yr_low$N3 
scenario1_N2yr_low$N5 <- C2_low %*% scenario1_N2yr_low$N4 
scenario1_N2yr_low$N6 <- S2_low %*% scenario1_N2yr_low$N5 
scenario1_N2yr_low$N7 <- C2_low %*% scenario1_N2yr_low$N6 
scenario1_N2yr_low$N8 <- S2_low %*% scenario1_N2yr_low$N7 
scenario1_N2yr_low$N9 <- C2_low %*% scenario1_N2yr_low$N8 
scenario1_N2yr_low$N10 <- S2_low %*% scenario1_N2yr_low$N9 
scenario1_N2yr_low$N11 <- C2_low %*% scenario1_N2yr_low$N10 
scenario1_N2yr_low$N12 <- S2_low %*% scenario1_N2yr_low$N11 

### 3-year conv
scenario1_N3yr_conv <- data.frame(matrix(ncol = 13, nrow = 2))
names(scenario1_N3yr_conv ) <- col_names 
scenario1_N3yr_conv$N0 <- N0
scenario1_N3yr_conv$N1 <- C3_conv %*% N0 
scenario1_N3yr_conv$N2 <- S3_conv %*% scenario1_N3yr_conv$N1
scenario1_N3yr_conv$N3 <- O3_conv %*% scenario1_N3yr_conv$N2 
scenario1_N3yr_conv$N4 <- C3_conv %*% scenario1_N3yr_conv$N3 
scenario1_N3yr_conv$N5 <- S3_conv %*% scenario1_N3yr_conv$N4
scenario1_N3yr_conv$N6 <- O3_conv %*% scenario1_N3yr_conv$N5 
scenario1_N3yr_conv$N7 <- C3_conv %*% scenario1_N3yr_conv$N6 
scenario1_N3yr_conv$N8 <- S3_conv %*% scenario1_N3yr_conv$N7
scenario1_N3yr_conv$N9 <- O3_conv %*% scenario1_N3yr_conv$N8 
scenario1_N3yr_conv$N10 <- C3_conv %*% scenario1_N3yr_conv$N9 
scenario1_N3yr_conv$N11 <- S3_conv %*% scenario1_N3yr_conv$N10
scenario1_N3yr_conv$N12 <- O3_conv %*% scenario1_N3yr_conv$N11 


### 3-year low
scenario1_N3yr_low <- data.frame(matrix(ncol = 13, nrow = 2))
names(scenario1_N3yr_low ) <- col_names 
scenario1_N3yr_low$N0 <- N0
scenario1_N3yr_low$N1 <- C3_low %*% N0 
scenario1_N3yr_low$N2 <- S3_low %*% scenario1_N3yr_low$N1
scenario1_N3yr_low$N3 <- O3_low %*% scenario1_N3yr_low$N2 
scenario1_N3yr_low$N4 <- C3_low %*% scenario1_N3yr_low$N3 
scenario1_N3yr_low$N5 <- S3_low %*% scenario1_N3yr_low$N4
scenario1_N3yr_low$N6 <- O3_low %*% scenario1_N3yr_low$N5 
scenario1_N3yr_low$N7 <- C3_low %*% scenario1_N3yr_low$N6 
scenario1_N3yr_low$N8 <- S3_low %*% scenario1_N3yr_low$N7
scenario1_N3yr_low$N9 <- O3_low %*% scenario1_N3yr_low$N8 
scenario1_N3yr_low$N10 <- C3_low %*% scenario1_N3yr_low$N9 
scenario1_N3yr_low$N11 <- S3_low %*% scenario1_N3yr_low$N10
scenario1_N3yr_low$N12 <- O3_low %*% scenario1_N3yr_low$N11 

### 4-year conv
scenario1_N4yr_conv <- data.frame(matrix(ncol = 13, nrow = 2))
names(scenario1_N4yr_conv ) <- col_names 
scenario1_N4yr_conv$N0 <- N0
scenario1_N4yr_conv$N1 <- C4_conv %*% N0 
scenario1_N4yr_conv$N2 <- S4_conv %*% scenario1_N4yr_conv$N1
scenario1_N4yr_conv$N3 <- O4_conv %*% scenario1_N4yr_conv$N2 
scenario1_N4yr_conv$N4 <- A4_conv %*% scenario1_N4yr_conv$N3 
scenario1_N4yr_conv$N5 <- C4_conv %*% scenario1_N4yr_conv$N4 
scenario1_N4yr_conv$N6 <- S4_conv %*% scenario1_N4yr_conv$N5
scenario1_N4yr_conv$N7 <- O4_conv %*% scenario1_N4yr_conv$N6 
scenario1_N4yr_conv$N8 <- A4_conv %*% scenario1_N4yr_conv$N7 
scenario1_N4yr_conv$N9 <- C4_conv %*% scenario1_N4yr_conv$N8  
scenario1_N4yr_conv$N10 <- S4_conv %*% scenario1_N4yr_conv$N9
scenario1_N4yr_conv$N11 <- O4_conv %*% scenario1_N4yr_conv$N10 
scenario1_N4yr_conv$N12 <- A4_conv %*% scenario1_N4yr_conv$N11 

### 4-year low
scenario1_N4yr_low <- data.frame(matrix(ncol = 13, nrow = 2))
names(scenario1_N4yr_low ) <- col_names 
scenario1_N4yr_low$N0 <- N0
scenario1_N4yr_low$N1 <- C4_low %*% N0 
scenario1_N4yr_low$N2 <- S4_low %*% scenario1_N4yr_low$N1
scenario1_N4yr_low$N3 <- O4_low %*% scenario1_N4yr_low$N2 
scenario1_N4yr_low$N4 <- A4_low %*% scenario1_N4yr_low$N3 
scenario1_N4yr_low$N5 <- C4_low %*% scenario1_N4yr_low$N4 
scenario1_N4yr_low$N6 <- S4_low %*% scenario1_N4yr_low$N5
scenario1_N4yr_low$N7 <- O4_low %*% scenario1_N4yr_low$N6 
scenario1_N4yr_low$N8 <- A4_low %*% scenario1_N4yr_low$N7 
scenario1_N4yr_low$N9 <- C4_low %*% scenario1_N4yr_low$N8  
scenario1_N4yr_low$N10 <- S4_low %*% scenario1_N4yr_low$N9
scenario1_N4yr_low$N11 <- O4_low %*% scenario1_N4yr_low$N10 
scenario1_N4yr_low$N12 <- A4_low %*% scenario1_N4yr_low$N11 

View(scenario1_N4yr_low )

## combine all the 6 crop id x corn weed management
scenario1_phase_seed_vectors <- rbind(scenario1_N2yr_conv,
                                      scenario1_N2yr_low,
                                      scenario1_N3yr_conv,
                                      scenario1_N3yr_low,
                                      scenario1_N4yr_conv,
                                      scenario1_N4yr_low)

```


```{r scenario1-eigen-rotation, echo=FALSE}
scenario1_rotation_group <- tibble::lst(scenario1_rotation_wise_2yr_conv,
                                     scenario1_rotation_wise_2yr_low,
                                     scenario1_rotation_wise_3yr_conv,
                                     scenario1_rotation_wise_3yr_low,
                                     scenario1_rotation_wise_4yr_conv,
                                     scenario1_rotation_wise_4yr_low)

scenario1_rotation_wise_projection <- scenario1_rotation_group %>%
  map(., ~{Reduce( "%*%", .)}) 

scenario1_rotation_wise_eigen <- scenario1_rotation_wise_projection %>%
  map(., ~{eigen.analysis(.)}) 

```

```{r scenario1-rotation-lambda, echo=FALSE}
scenario1_rotation_wise_lambda <- scenario1_rotation_wise_eigen %>%
  map(., ~{head(.,1)}) 

# make a df to admend to the next chunk's df 

scenario1_rotation_wise_lambda_df <- scenario1_rotation_wise_lambda %>%
   plyr::ldply(., data.frame)
```



```{r scenario1-lambda-annualized-df, echo=FALSE}
scenario1_annualized_lambda_2yr <- rapply(scenario1_rotation_wise_lambda[1:2],
                                             function(x){nthroot(x,2)}, how = "list")    

scenario1_annualized_lambda_3yr <- rapply(scenario1_rotation_wise_lambda[3:4],
                                             function(x){nthroot(x,3)}, how = "list")

scenario1_annualized_lambda_4yr <- rapply(scenario1_rotation_wise_lambda[5:6],
                                             function(x){nthroot(x,4)}, how = "list")
   
scenario1_annualized_lambda_df <- tibble::lst(scenario1_annualized_lambda_2yr,
                                   scenario1_annualized_lambda_3yr,
                                   scenario1_annualized_lambda_4yr) %>%
   plyr::ldply(., data.frame) %>% 
  rename(conv = "lambda1", low = "lambda1.1")

scenario1_annualized_lambda_df_long <- scenario1_annualized_lambda_df %>%
  pivot_longer(!.id, names_to = "Corn_weed_management", values_to = "annualized_lambda") 

# View(scenario1_annualized_lambda_df_long)

## add the rotation-wise lambdas to the annualized lambdas 
scenario1_annualized_lambda_df_long$rot_wise_lambda <-  scenario1_rotation_wise_lambda_df$lambda1
```


```{r scenario1-circ-2yr-arrange, echo=FALSE, warning=FALSE, message=FALSE}
### conventional 

# pick all phases in the 2yr conventional treatment and arrange in backward order, i.e., first sub-annual matrix in the first crop phase at the right-most (or bottom) position of the list
scenario1_all_periods_2yr_conv <- scenario1_projection_by_matrix_id_transpose[c("S2_conv", "C2_conv")]
#View(scenario1_all_periods_2yr_conv)

# remove the phase bounded structure in a chain, making a chain of 12 subannual matrices for the 2-year rotation
scenario1_all_periods_2yr_conv_chain <- unlist(scenario1_all_periods_2yr_conv, recursive = FALSE)

# make a reference grid, based on a chain starting at the spring_tillage matrix
scenario1_ref_2yr_conv <- names(scenario1_all_periods_2yr_conv_chain)

# create circular rotation of the first subannual matrix in each chain
scenario1_circ_2yr_conv <- circ(scenario1_ref_2yr_conv)

scenario1_full_circ_2yr_conv <- purrr::map(1:12,~scenario1_all_periods_2yr_conv_chain[scenario1_circ_2yr_conv[.x,]])
# name the nested list by the last element in each nested list
# the last element in each nested list appear in the same order as circ_2yr_conv[,12]

names(scenario1_full_circ_2yr_conv) <- paste0(scenario1_circ_2yr_conv[,12],"_contribution") 

# check if nested lists names matches their last elements' names: YES
# View( scenario1_full_circ_2yr_conv) check

# remove the last subannual matrix from the chain in full_circ_2yr_conv:
scenario1_until_circ_2yr_conv <- scenario1_full_circ_2yr_conv  %>%
  map(., ~{head(.,11)})
#  Each chain now has 11 matrixe. In term of contribution to changes in lambda, each chain starts at the subannual matrix following the matrix of interest. The `until` and `though` designation is detailed in Caswell and Trevisan 1994. 
### low

# pick all phases in the 2yr conventional treatment
scenario1_all_periods_2yr_low <- scenario1_projection_by_matrix_id_transpose[c("S2_low", "C2_low")]
#View(all_periods_2yr_conv)

# rearrange the phases in a chain
scenario1_all_periods_2yr_low_chain <- unlist(scenario1_all_periods_2yr_low, recursive = FALSE)

# make a reference grid 
scenario1_ref_2yr_low <- names(scenario1_all_periods_2yr_low_chain)

scenario1_circ_2yr_low <- circ(scenario1_ref_2yr_low)

scenario1_full_circ_2yr_low <- purrr::map(1:12,~scenario1_all_periods_2yr_low_chain[scenario1_circ_2yr_low[.x,]])
# name the nested list by the last element in each nested list
# the last element in each nested list appear in the same order as circ_2yr_low[,12]

names(scenario1_full_circ_2yr_low) <- paste0(scenario1_circ_2yr_low[,12],"_contribution") 

# check if nested lists names matches their last elements' names: YES
# View( full_circ_2yr_low): each chain's product is identified by the right-most matrix 

# remove the last subannual matrix from the chain in full_circ_2yr_low
scenario1_until_circ_2yr_low <- scenario1_full_circ_2yr_low %>%
  map(., ~{head(.,11)})
```


```{r scenario1-LTRE-2yr, echo=FALSE}
## In all LTRE procedures, the conventional treatment is the reference matrix and low the treatment of interest

# left matrix multiplication of all chains (as defined by starting point, aka the right-most matrix of the chain) THROUGH the right-most matrix --> matrix A's

# The product of each list in the full_circ_2yr_xx is A(hk),
# A(hk) is the product of all sub-annual period starting at phase k, period h
scenario1_A2_conv_contribution <- scenario1_full_circ_2yr_conv %>%  
  map(., ~{Reduce( "%*%", .)}) 

scenario1_A2_low_contribution <- scenario1_full_circ_2yr_low %>% 
  map(., ~{Reduce( "%*%", .)}) 

scenario1_A2_contribution <- lst(scenario1_A2_conv_contribution, scenario1_A2_low_contribution)

# calculate the A* matrix, average of the two products representing conventional and low corn weed management treatments 

scenario1_A2_avg_contribution <- lapply(Reduce(\(...)Map('+', ...), scenario1_A2_contribution), '/', length(scenario1_A2_contribution))

# Matrix S_A(h)'s: sensitivity of lambda to each element of A(h), i.e. a(ijh), using matrix A*
scenario1_A2_avg_sens <- scenario1_A2_avg_contribution %>%
  map(., ~{sensitivity(.)})

# Matrix D: the product of all sub-annual matrices in backward order, until the B(h) matrix appear. 
# other words: left matrix multiplication of all chains (as defined by starting point, B(h), UNTIL the B(h) appear, the chain that makes up D is one matrix fewer than one that makes S

scenario1_D2_conv_contribution <- scenario1_until_circ_2yr_conv %>% 
  map(., ~{Reduce( "%*%", .)}) 

scenario1_D2_low_contribution <- scenario1_until_circ_2yr_low %>% 
  map(., ~{Reduce( "%*%", .)}) 

scenario1_D2_contribution <- lst(scenario1_D2_conv_contribution, scenario1_D2_low_contribution)

### Do I really need D_avg? ### Yes

scenario1_D2_avg_contribution <- lapply(Reduce(\(...)Map('+', ...), scenario1_D2_contribution), '/', length(scenario1_D2_contribution))

scenario1_D2_avg_contribution_transposed <- scenario1_D2_avg_contribution %>%
  map(., ~{t(.)})

# Matrix S_B(h):  sensitivity of lambda to changes in each element of the subannual matrix B(h)  
scenario1_S_B_contribution_2yr <- purrr::map2(scenario1_D2_avg_contribution_transposed, scenario1_A2_avg_sens, `%*%`)

# remove "conv" in all names, conv was picked up from D2_conv_contribution because it was listed first in D2_contribution. 

## pick out the names
scenario1_contribution_2yr_raw_names <- names( scenario1_S_B_contribution_2yr)

## remove "conv" in all names
scenario1_contribution_2yr_names <- gsub('conv.', '', scenario1_contribution_2yr_raw_names)
## put the names back
names(scenario1_S_B_contribution_2yr) <- scenario1_contribution_2yr_names

# View(scenario1_S_B_contribution_2yr )
```



```{r scenario1-elasticity-2yr, echo=FALSE}
# lambda at scenario1_annualized_lambda_df_long$annualized_lamb View(scenario1_annualized_lambda_df_long)
scenario1_lambda_2yr_conv <- scenario1_annualized_lambda_df_long$annualized_lambda[1]

scenario1_lambda_2yr_low <-scenario1_annualized_lambda_df_long$annualized_lambda[2]
# Elasticity contribution left: check if all_periods_2yr_conv_chain is the appropriate element 
# The right-most matrix of all_periods_2yr_conv_chain is C2_spring_tillage
# why is the order of "all_periods_2yr_conv_chain" and "sens_contribution_2yr" opposite?

# Elasticity contribution left component: b_hij_2/lambda, or _3, _4 in the later chunks 
scenario1_b_hij_2_over_lambda_conv <-  scenario1_all_periods_2yr_conv_chain %>%
  map(., ~{./scenario1_lambda_2yr_conv})

scenario1_b_hij_2_over_lambda_low <-  scenario1_all_periods_2yr_low_chain %>%
  map(., ~{./scenario1_lambda_2yr_low})

# Elasticity contribution right component: S_B's 

# Multiply the left and right components 
scenario1_E_B_contribution_2yr_conv <- Map(\(x, y) Reduce(`%*%`, list(x, y)), scenario1_b_hij_2_over_lambda_conv, scenario1_S_B_contribution_2yr)

## pick out the names
scenario1_E_B_contribution_2yr_conv_raw_names <- names(scenario1_E_B_contribution_2yr_conv )

## rename "means" with "E_B" in list names, for identification

scenario1_E_B_contribution_2yr_conv_names <- gsub('mean', 'E_B', scenario1_E_B_contribution_2yr_conv_raw_names )
## put the names back
names(scenario1_E_B_contribution_2yr_conv ) <- scenario1_E_B_contribution_2yr_conv_names 

scenario1_E_B_contribution_2yr_low <- Map(\(x, y) Reduce(`%*%`, list(x, y)), scenario1_b_hij_2_over_lambda_low, scenario1_S_B_contribution_2yr)

## pick out the names
scenario1_E_B_contribution_2yr_low_raw_names <- names(scenario1_E_B_contribution_2yr_low)

## rename "means" with "E_B" in list names, for identification

scenario1_E_B_contribution_2yr_low_names <- gsub('mean', 'E_B', scenario1_E_B_contribution_2yr_low_raw_names )
## put the names back
names(scenario1_E_B_contribution_2yr_low ) <- scenario1_E_B_contribution_2yr_low_names 

```

```{r scenario1-circ-3yr-arrange, echo=FALSE, warning=FALSE, message=FALSE}
### conventional 

# pick all phases in the 3yr conventional treatment
scenario1_all_periods_3yr_conv <- scenario1_projection_by_matrix_id_transpose[c("O3_conv", "S3_conv", "C3_conv")]
#View(all_periods_3yr_conv)

# rearrange the phases in a chain
scenario1_all_periods_3yr_conv_chain <- unlist(scenario1_all_periods_3yr_conv, recursive = FALSE)

# make a reference grid 
scenario1_ref_3yr_conv <- names(scenario1_all_periods_3yr_conv_chain)

scenario1_circ_3yr_conv <- circ(scenario1_ref_3yr_conv)

scenario1_full_circ_3yr_conv <- purrr::map(1:18,~scenario1_all_periods_3yr_conv_chain[scenario1_circ_3yr_conv[.x,]])
# name the nested list by the last element in each nested list
# the last element in each nested list appear in the same order as circ_3yr_conv[,12]

names(scenario1_full_circ_3yr_conv) <- paste0(scenario1_circ_3yr_conv[,18],"_contribution") 

# check if nested lists names matches their last elements' names: YES
# View( full_circ_2yr_conv) check

# remove the last subannual matrix from the chain in full_circ_3yr_conv
scenario1_until_circ_3yr_conv <- scenario1_full_circ_3yr_conv  %>%
  map(., ~{head(.,11)})

### low

# pick all phases in the 3yr low treatment
scenario1_all_periods_3yr_low <- scenario1_projection_by_matrix_id_transpose[c("O3_low", "S3_low", "C3_low")]
#View(all_periods_2yr_conv)

# rearrange the phases in a chain
scenario1_all_periods_3yr_low_chain <- unlist(scenario1_all_periods_3yr_low, recursive = FALSE)

# make a reference grid 
scenario1_ref_3yr_low <- names(scenario1_all_periods_3yr_low_chain)

scenario1_circ_3yr_low <- circ(scenario1_ref_3yr_low)

scenario1_full_circ_3yr_low <- purrr::map(1:18,~scenario1_all_periods_3yr_low_chain[scenario1_circ_3yr_low[.x,]])
# name the nested list by the last element in each nested list
# the last element in each nested list appear in the same order as circ_3yr_low[,12]

names(scenario1_full_circ_3yr_low) <- paste0(scenario1_circ_3yr_low[,18],"_contribution") 

# check if nested lists names matches their last elements' names: YES
# View( scenario1_full_circ_3yr_low) 

# remove the last subannual matrix from the chain in full_circ_3yr_low
scenario1_until_circ_3yr_low <- scenario1_full_circ_3yr_low %>%
  map(., ~{head(.,11)})
```

```{r scenario1-LTRE-3yr, echo=FALSE}
## In all LTRE procedures, the conventional treatment is the reference matrix and low the

# left matrix multiplication of all chains (as defined by starting point, aka the right-most matrix of the chain) THROUGH the right-most matrix --> matrix A's
scenario1_A3_conv_contribution <- scenario1_full_circ_3yr_conv %>% 
  map(., ~{Reduce( "%*%", .)}) 

scenario1_A3_low_contribution <- scenario1_full_circ_3yr_low %>% 
  map(., ~{Reduce( "%*%", .)}) 

scenario1_A3_contribution <- lst(scenario1_A3_conv_contribution, scenario1_A3_low_contribution)

scenario1_A3_avg_contribution <- lapply(Reduce(\(...)Map('+', ...), scenario1_A3_contribution), '/', length(scenario1_A3_contribution))

# Sensitivities with regards to the right-most matrix --> matrix S_a's
scenario1_A3_avg_sens <- scenario1_A3_avg_contribution %>%
  map(., ~{sensitivity(.)})

# left matrix multiplication of all chains (as defined by starting point, aka the right-most matrix of the chain) UNTIL the right-most matrix appear --> matrix D's

scenario1_D3_conv_contribution <- scenario1_until_circ_3yr_conv %>% 
  map(., ~{Reduce( "%*%", .)}) 

scenario1_D3_low_contribution <- scenario1_until_circ_3yr_low %>% 
  map(., ~{Reduce( "%*%", .)}) 

scenario1_D3_contribution <- lst(scenario1_D3_conv_contribution, scenario1_D3_low_contribution)

scenario1_D3_avg_contribution <- lapply(Reduce(\(...)Map('+', ...), scenario1_D3_contribution), '/', length(scenario1_D3_contribution))

scenario1_S_B_contribution_3yr <- purrr::map2(scenario1_D3_avg_contribution, scenario1_A3_avg_sens, `%*%`)

# remove "conv" in all names
scenario1_contribution_3yr_raw_names <- names(scenario1_S_B_contribution_3yr )

scenario1_contribution_3yr_names <- gsub('conv.', '', scenario1_contribution_3yr_raw_names)

names(scenario1_S_B_contribution_3yr) <- scenario1_contribution_3yr_names
```

```{r scenario1-elasticity-3yr, echo=FALSE}
# lambda at scenario1_rotation_wise_lambda 
scenario1_lambda_3yr_conv <- scenario1_annualized_lambda_df_long$annualized_lambda[3]

scenario1_lambda_3yr_low <- scenario1_annualized_lambda_df_long$annualized_lambda[4]


# Elasticity contribution left component: b_hij_3/lambda,
scenario1_b_hij_3yr_over_lambda_conv <-  scenario1_all_periods_3yr_conv_chain %>%
  map(., ~{./scenario1_lambda_3yr_conv})

scenario1_b_hij_3yr_over_lambda_low <-  scenario1_all_periods_3yr_low_chain %>%
  map(., ~{./scenario1_lambda_3yr_low})

# Elasticity contribution right component: S_B's 

# ## Calculate E_Bs: Multiply the left and right components 
scenario1_E_B_contribution_3yr_conv <- Map(\(x, y) Reduce(`%*%`, list(x, y)), scenario1_b_hij_3yr_over_lambda_conv, scenario1_S_B_contribution_3yr)
## pick out the names
scenario1_E_B_contribution_3yr_conv_raw_names <- names(scenario1_E_B_contribution_3yr_conv )

## rename "means" with "E_B" in list names, for identification

scenario1_E_B_contribution_3yr_conv_names <- gsub('mean', 'E_B', scenario1_E_B_contribution_3yr_conv_raw_names )
## put the names back
names(scenario1_E_B_contribution_3yr_conv ) <- scenario1_E_B_contribution_3yr_conv_names 


## Calculate E_Bs
scenario1_E_B_contribution_3yr_low <- Map(\(x, y) Reduce(`%*%`, list(x, y)), scenario1_b_hij_3yr_over_lambda_low, scenario1_S_B_contribution_3yr)

## pick out the names
scenario1_E_B_contribution_3yr_low_raw_names <- names(scenario1_E_B_contribution_3yr_low)

## rename "means" with "E_B" in list names, for identification

scenario1_E_B_contribution_3yr_low_names <- gsub('mean', 'E_B', scenario1_E_B_contribution_3yr_low_raw_names )
## put the names back
names(scenario1_E_B_contribution_3yr_low ) <- scenario1_E_B_contribution_3yr_low_names 
```

```{r scenario1-circ-4yr-arrange, echo=FALSE, warning=FALSE, message=FALSE}
### conventional 

# pick all phases in the 4yr conventional treatment
scenario1_all_periods_4yr_conv <- scenario1_projection_by_matrix_id_transpose[c("A4_conv", "O4_conv", "S4_conv", "C4_conv")]
# View(scenario1_all_periods_4yr_conv)

# rearrange the phases in a chain
scenario1_all_periods_4yr_conv_chain <- unlist(scenario1_all_periods_4yr_conv, recursive = FALSE)

# make a reference grid 
scenario1_ref_4yr_conv <- names(scenario1_all_periods_4yr_conv_chain)

scenario1_circ_4yr_conv <- circ(scenario1_ref_4yr_conv)

scenario1_full_circ_4yr_conv <- purrr::map(1:24,~scenario1_all_periods_4yr_conv_chain[scenario1_circ_4yr_conv[.x,]])
# name the nested list by the last element in each nested list
# the last element in each nested list appear in the same order as scenario1_circ_4yr_conv[,12]

names(scenario1_full_circ_4yr_conv) <- paste0(scenario1_circ_4yr_conv[,24],"_contribution") 

# check if nested lists names matches their last elements' names: YES
# View( scenario1_full_circ_4yr_conv) check

# remove the last subannual matrix from the chain in full_circ_3yr_conv
scenario1_until_circ_4yr_conv <- scenario1_full_circ_4yr_conv  %>%
  map(., ~{head(.,11)})

### low

# pick all phases in the 3yr low treatment
scenario1_all_periods_4yr_low <- scenario1_projection_by_matrix_id_transpose[c("A4_low", "O4_low", "S4_low", "C4_low")]
#View(all_periods_4yr_conv)

# rearrange the phases in a chain
scenario1_all_periods_4yr_low_chain <- unlist(scenario1_all_periods_4yr_low, recursive = FALSE)

# make a reference grid 
scenario1_ref_4yr_low <- names(scenario1_all_periods_4yr_low_chain)

scenario1_circ_4yr_low <- circ(scenario1_ref_4yr_low)

scenario1_full_circ_4yr_low <- purrr::map(1:24,~scenario1_all_periods_4yr_low_chain[scenario1_circ_4yr_low[.x,]])
# name the nested list by the last element in each nested list
# the last element in each nested list appear in the same order as scenario1_circ_4yr_low[,12]

names(scenario1_full_circ_4yr_low) <- paste0(scenario1_circ_4yr_low[,24],"_contribution") 

# check if nested lists names matches their last elements' names: YES
# View( scenario1_full_circ_4yr_low) 

# remove the last subannual matrix from the chain in full_circ_4yr_low
scenario1_until_circ_4yr_low <- scenario1_full_circ_4yr_low %>%
  map(., ~{head(.,11)})
```

```{r scenario1-LTRE-4yr, echo=FALSE}
## In all LTRE procedures, the conventional treatment is the reference matrix and low the

# left matrix multiplication of all chains (as defined by starting point, aka the right-most matrix of the chain) THROUGH the right-most matrix --> matrix A's
scenario1_A4_conv_contribution <- scenario1_full_circ_4yr_conv %>% 
  map(., ~{Reduce( "%*%", .)}) 

scenario1_A4_low_contribution <- scenario1_full_circ_4yr_low %>% 
  map(., ~{Reduce( "%*%", .)}) 

scenario1_A4_contribution <- lst(scenario1_A4_conv_contribution, scenario1_A4_low_contribution)

scenario1_A4_avg_contribution <- lapply(Reduce(\(...)Map('+', ...), scenario1_A4_contribution), '/', length(scenario1_A4_contribution))

# Sensitivities with regards to the right-most matrix --> matrix S_A's
scenario1_A4_avg_sens <- scenario1_A4_avg_contribution %>%
  map(., ~{sensitivity(.)})

# left matrix multiplication of all chains (as defined by starting point, aka the right-most matrix of the chain) UNTIL the right-most matrix appear --> matrix D's

scenario1_D4_conv_contribution <- scenario1_until_circ_4yr_conv %>% 
  map(., ~{Reduce( "%*%", .)}) 

scenario1_D4_low_contribution <- scenario1_until_circ_4yr_low %>% 
  map(., ~{Reduce( "%*%", .)}) 

scenario1_D4_contribution <- lst(scenario1_D4_conv_contribution, scenario1_D4_low_contribution)

scenario1_D4_avg_contribution <- lapply(Reduce(\(...)Map('+', ...), scenario1_D4_contribution), '/', length(scenario1_D4_contribution))

scenario1_D4_avg_contribution_transposed <- scenario1_D4_avg_contribution %>% map(.,~{t(.)})

## contribution of each sub-annual matrix to lambda's sensitivities, matrix S_B's                                     
scenario1_S_B_contribution_4yr <- purrr::map2(scenario1_D4_avg_contribution_transposed, scenario1_A4_avg_sens, `%*%`)
# remove "conv" in all names
scenario1_S_B_contribution_4yr_raw_names <- names( scenario1_S_B_contribution_4yr)

scenario1_S_B_contribution_4yr_names <- gsub('conv.', '', scenario1_S_B_contribution_4yr_raw_names)

names(scenario1_S_B_contribution_4yr) <- scenario1_S_B_contribution_4yr_names
```

```{r scenario1-elasticity-4yr, echo=FALSE}
## calculate elasticity, see p. 121

## NEED NEW NAMES FOR ALL THE LIST
# lambda at scenario1_rotation_wise_lambda 
scenario1_lambda_4yr_conv <- scenario1_annualized_lambda_df_long$annualized_lambda[5]

scenario1_lambda_4yr_low <-scenario1_annualized_lambda_df_long$annualized_lambda[6]
# Elasticity contribution left: check if all_periods_4yr_conv_chain is the appropriate element 
# The right-most matrix of all_periods_4yr_conv_chain is C4_spring_tillage
# why is the order of "all_periods_4yr_conv_chain" and "sens_contribution_4yr" opposite?


scenario1_b_hij_4yr_over_lambda_conv_left <-  scenario1_all_periods_4yr_conv_chain %>%
  map(., ~{./scenario1_lambda_4yr_conv})

scenario1_b_hij_4yr_over_lambda_low_left <-  scenario1_all_periods_4yr_low_chain %>%
  map(., ~{./scenario1_lambda_4yr_low})

# Elasticity contribution right component: S_B's sens_contribution_4yr

# Elasticity
scenario1_E_B_contribution_4yr_conv  <- Map(\(x, y) Reduce(`%*%`, list(x, y)),
                                  scenario1_b_hij_4yr_over_lambda_conv_left ,
                                  scenario1_S_B_contribution_4yr)
## pick out the names
scenario1_E_B_contribution_4yr_conv_raw_names <- names(scenario1_E_B_contribution_4yr_conv )

## rename "means" with "E_B" in list names, for identification

scenario1_E_B_contribution_4yr_conv_names <- gsub('mean', 'E_B', scenario1_E_B_contribution_4yr_conv_raw_names )
## put the names back
names(scenario1_E_B_contribution_4yr_conv ) <- scenario1_E_B_contribution_4yr_conv_names 


scenario1_E_B_contribution_4yr_low  <- Map(\(x, y) Reduce(`%*%`, list(x, y)),
                                 scenario1_b_hij_4yr_over_lambda_low_left,
                                 scenario1_S_B_contribution_4yr)

## pick out the names
scenario1_E_B_contribution_4yr_low_raw_names <- names(scenario1_E_B_contribution_4yr_low)

## rename "means" with "E_B" in list names, for identification

scenario1_E_B_contribution_4yr_low_names <- gsub('mean', 'E_B', scenario1_E_B_contribution_4yr_low_raw_names )
## put the names back
names(scenario1_E_B_contribution_4yr_low ) <- scenario1_E_B_contribution_4yr_low_names 
```

```{r scenario1-var-list, echo=FALSE}
# <https://en.wikipedia.org/wiki/Taylor_expansions_for_the_moments_of_functions_of_random_variables> .

## Need variance separated for each parameters in the summer survival period 
## issue: things happening at the same period need to be in one matrix 
## work-around: comment on period-based changes instead of parameter-based changes 


## Combine all variance lists into one grand list, similar to the means list

## Variance list needed for each rotation, but in the opposite order as in the mean list, to accommodate the order of the S_B list

var_scenario1_projection_by_matrix_id <- tibble::lst(var_spring_tillage,
                                                     scenario1_var_emergence,
                                                      scenario1_var_summer_survival,
                                                       scenario1_var_fecundity_2019,
                                                        var_post_harvest_tillage,
                                                     scenario1_var_overwinter)
# A list of 12 bested list
var_scenario1_projection_by_matrix_id_named <- rapply(var_scenario1_projection_by_matrix_id , 
                                                  function(x) {dimnames(x) <- rep(list(c("seed_top",
                                                                                        "seed_bottom", 
                                                                                        "plant_cohort_1",
                                                                                        "plant_cohort_2",
                                                                                        "plant_cohort_3",
                                                                                        "plant_cohort_4",
                                                                                        "plant_cohort_5",
                                                                                        "plant_cohort_6")),2); x}, how="list")

# Transpose the var list to rearrange will create a nested list of 18 lists of 12 matrices each
var_scenario1_projection_transpose <- purrr::transpose(var_scenario1_projection_by_matrix_id_named)

# Separate variance by rotation x corn weed management 
var_scenario1_projection_2yr_conv <- var_scenario1_projection_transpose[c("C2_conv","S2_conv")]
var_scenario1_projection_2yr_conv_unlist <- unlist(var_scenario1_projection_2yr_conv, recursive = FALSE)

var_scenario1_projection_2yr_low <- var_scenario1_projection_transpose[c("C2_low","S2_low")]
var_scenario1_projection_2yr_low_unlist <- unlist(var_scenario1_projection_2yr_low, recursive = FALSE)

var_scenario1_projection_3yr_conv <- var_scenario1_projection_transpose[c("C3_conv","S3_conv", "O3_conv")]
var_scenario1_projection_3yr_conv_unlist <- unlist(var_scenario1_projection_3yr_conv, recursive = FALSE)

var_scenario1_projection_3yr_low <- var_scenario1_projection_transpose[c("C3_low","S3_low", "O3_low")]
var_scenario1_projection_3yr_low_unlist <- unlist(var_scenario1_projection_3yr_low, recursive = FALSE)

var_scenario1_projection_4yr_conv <- var_scenario1_projection_transpose[c("C4_conv","S4_conv", "O4_conv", "A4_conv")]
var_scenario1_projection_4yr_conv_unlist <- unlist(var_scenario1_projection_4yr_conv, recursive = FALSE)

var_scenario1_projection_4yr_low <- var_scenario1_projection_transpose[c("C4_low","S4_low", "O4_low", "A4_low")]
var_scenario1_projection_4yr_low_unlist <- unlist(var_scenario1_projection_4yr_low, recursive = FALSE)
# recombine variance using the same order as S_B

var_scenario1_projection_conv <- tibble::lst(var_scenario1_projection_2yr_conv_unlist,
                                             var_scenario1_projection_3yr_conv_unlist,
                                             var_scenario1_projection_4yr_conv_unlist)

#View(var_scenario1_projection_conv)



var_scenario1_projection_low <- tibble::lst(var_scenario1_projection_2yr_low_unlist,
                                             var_scenario1_projection_3yr_low_unlist,
                                             var_scenario1_projection_4yr_low_unlist)

#View(var_scenario1_projection_low)
```

```{r scenario1-S-B-recombine, echo=FALSE}
## Gather S_B contribution lists by sub-annual matrices: all the spring tillage matrices in 6 cropping systems together, all the emergence matrices together, ...

scenario1_S_B_contribution_recombined <- tibble::lst(scenario1_S_B_contribution_2yr, 
                                           scenario1_S_B_contribution_3yr,
                                           scenario1_S_B_contribution_4yr)


## Trim each matrix in the recombined S_B contribution list to the needed n row x 1 column
#https://stackoverflow.com/questions/72326431/extract-the-same-column-from-all-matrices-in-a-nested-list/72326729#72326729

scenario1_S_B_contribution_recombined_first_col <- rapply(scenario1_S_B_contribution_recombined, \(x) x[, 1, drop=FALSE], how='list')

## Transpose the trimmed S_B list

scenario1_S_B_contribution_recombined_first_col_transpose <- rapply(scenario1_S_B_contribution_recombined_first_col, \(x) t(x), how='list')
```

```{r scenario1-var-rot-lambda, echo=FALSE}
scenario1_var_lambda_conv_elements  <- Map(\(x, y, z) Reduce(`%*%`,
                      list(x, y, z)),
    unlist(scenario1_S_B_contribution_recombined_first_col_transpose, recursive = F),
    unlist(var_scenario1_projection_conv, recursive = F),
    unlist(scenario1_S_B_contribution_recombined_first_col, recursive = F))

scenario1_var_lambda_conv_2yr <- sum(unlist(scenario1_var_lambda_conv_elements[1:12]))
scenario1_var_lambda_conv_3yr <- sum(unlist(scenario1_var_lambda_conv_elements[13:30]))
scenario1_var_lambda_conv_4yr <- sum(unlist(scenario1_var_lambda_conv_elements[31:54]))

scenario1_var_lambda_low_elements  <- Map(\(x, y, z) Reduce(`%*%`,
                      list(x, y, z)),
    unlist(scenario1_S_B_contribution_recombined_first_col_transpose, recursive = F),
    unlist(var_scenario1_projection_low, recursive = F),
    unlist(scenario1_S_B_contribution_recombined_first_col, recursive = F))



scenario1_var_lambda_low_2yr <- sum(unlist(scenario1_var_lambda_low_elements[1:12]))
scenario1_var_lambda_low_3yr <- sum(unlist(scenario1_var_lambda_low_elements[13:30]))
scenario1_var_lambda_low_4yr <- sum(unlist(scenario1_var_lambda_low_elements[31:54]))
```


```{r scenario1-var-annualized-lambda, echo=FALSE}
# combine all variance into a data frame and calculate annualized lambda's var

scenario1_annualized_lambda_df_long$Rotation_var_lambda <- c(scenario1_var_lambda_conv_2yr,
                                      scenario1_var_lambda_low_2yr,
                                      scenario1_var_lambda_conv_3yr,
                                      scenario1_var_lambda_low_3yr,
                                      scenario1_var_lambda_conv_4yr,
                                      scenario1_var_lambda_low_4yr)

# add multiplier to the var table
scenario1_annualized_lambda_df_long$multiplier <- c(1/4, 1/4, 1/9, 1/9, 1/16, 1/16)



# how to explain negative variance components?


# combine lambda, var(lambda), and *variance contribution* and rename the data frame
scenario1_annualized_lambda_and_var <- scenario1_annualized_lambda_df_long %>%
  mutate(squared_annualized_lambda = annualized_lambda^2,
         var_annualized_lambda = multiplier * Rotation_var_lambda/squared_annualized_lambda,
         Scenario = "1") %>%
  select(Scenario, .id, Corn_weed_management, annualized_lambda, var_annualized_lambda)


## subset all the lists
#View( scenario1_annualized_lambda_and_var)
#https://community.rstudio.com/t/subset-a-nested-list-to-get-all-the-lower-level-lists-with-the-same-characters-in-their-names/138320

scenario1_var_lambda_conv_top_element <- scenario1_var_lambda_conv_elements[str_detect(names(scenario1_var_lambda_conv_elements), "summer")]

scenario1_var_lambda_conv_second_elements <-  scenario1_var_lambda_conv_elements[str_detect(names(scenario1_var_lambda_conv_elements), "fecund")]

scenario1_var_lambda_low_top_element <- scenario1_var_lambda_low_elements[str_detect(names(scenario1_var_lambda_low_elements), "summer")]

scenario1_var_lambda_low_second_element <- scenario1_var_lambda_low_elements[str_detect(names(scenario1_var_lambda_low_elements), "fecund")]
```


```{r scenario1-phase-wise-lambda-plot, echo=FALSE, fig.width= 8, fig.height= 12, fig.cap= "Scenario 1: Changes of a seed column after twelve model years in three rotations (2-year, 3-year, and 4-year) crossed with two corn weed management programs (conventional and low herbicide). The model started at year 0 with 1000 and 0 seeds per squared meter at the top (0-2 cm) and bottom (2-20 cm) strata, respectively. The red horizontal line shows the number of seeds at the top stratum at the begining of the model clock. The annualized population growth rates are followed by their variances in brackets. The models years are followed by the main crop species names' abbreviations: C - corn, S - soybean, O - oat, and A - alfalfa."}

#scenario1_phase_seed_vectors$Sequence <- c(rep("start-C-S-C-S-C-S-C-S-C-S-C-S",2),
#                                           rep( "start-C-S-O-C-S-O-C-S-O-C-S-O",2),
#                                           rep( "start-C-S-O-A-C-S-O-A-C-S-O-A",2))
## Convert the seed vectors to long format
scenario1_phase_seed_vectors_long <- scenario1_phase_seed_vectors %>%
  mutate(Stratum = rep(c("0-2 cm", "2-20 cm"),6),
         Rotation = c(rep("2-year",4), rep("3-year",4), rep("4-year",4)),
         Corn_weed_management = rep(c("conventional", "conventional", "low", "low"),3)) %>%
  pivot_longer(!c(Stratum:Corn_weed_management), names_to = "Step", values_to = "Count") %>%
  mutate(Year = as.numeric(substring(Step, 2)),
         Sequence = c(rep(c("start", "C", "S", "C", "S", "C", "S", "C", "S", "C", "S", "C", "S"),4),
                      rep(c("start", "C", "S", "O", "C", "S", "O", "C", "S", "O", "C", "S", "O"),4),
                      rep(c("start", "C", "S", "O", "A", "C", "S", "O", "A", "C", "S", "O", "A"),4)),
         Year_Crop = paste(Year, Sequence, sep = "/"))

# View( scenario1_phase_seed_vectors_long)



## customize lambda table for facet annotation
# View(scenario1_annualized_lambda_and_var )
# https://stackoverflow.com/questions/72426613/individual-text-box-with-greek-letter-on-each-facet-grid-panel/72426740#72426740
lambda_label <- data.frame(
  label = c("\u03BB = 0.567 (1663.3)",  "\u03BB = 0.544 (46598.7)", "\u03BB = 0.701 (268.9)",
            "\u03BB = 0.537 (1876.0)", "\u03BB = 0.542 (46996.3)", "\u03BB = 0.968 (141.3)"),
  Rotation = rep(c("2-year", "3-year", "4-year"), 2),
  Corn_weed_management = rep(c("conventional", "low"), 3),
  Stratum = rep("placeholder", 6) #need this placeholder for the geom_text in the code chain below to run
)

## reverse legend: https://www.geeksforgeeks.org/reversing-the-order-of-a-ggplot2-legend/
scenario1_phase_seed_vectors_long  %>% 
  ggplot() +
  aes(x = factor(Year_Crop, levels=unique(Year_Crop)), group = Stratum) +
 #  aes(x = as.factor(Year), y = Count, group = Stratum) +
  geom_line(aes(y = Count, linetype =  Stratum)) +
  geom_point(aes(y = Count, shape =  Stratum)) +
  geom_hline(aes(yintercept = 1000, color = "baseline")) +
  facet_wrap(Rotation ~ Corn_weed_management, scales = "free_x", ncol = 2, labeller = label_wrap_gen(multi_line=FALSE)) + 
 # scale_x_continuous(breaks = scales::pretty_breaks(n = 13)) + don't need this with as.factor(Year)
  labs(x = "Model year/Crop species abbreviation",
       y= expression(paste("Seed density (", seeds~m^-2,")"))) +
  theme(axis.text.x = element_text(angle = 90)) +
  theme(legend.position = "bottom", legend.title = element_blank(),
        legend.key = element_rect(fill = "transparent", colour = "transparent"),
        panel.background=element_rect(fill="transparent",colour=NA),
      plot.background=element_rect(fill="transparent",colour=NA)) +
  #annotate("text", label = paste("\u03BB =", c("0.567 (1663.3)", "0.537 (1876.0)", "0.544 (46598.7)", "0.542 (46996.3)", "0.701 (268.9)", "0.968 (141.3)")) , size = 3, x = 8, y = 10000) +
  geom_text(data = lambda_label, aes(label = label), size = 3, x = 8, y = 10500) +
  guides(colour = "none") 
# one layered panel name <https://stackoverflow.com/questions/45699411/facet-label-merging-into-a-single-row-ggplot2>
# none of facet_nested_wrap, or lemon::'s is working
```


```{r scenario1-all-E-B, include=FALSE}
scenario1_E_B_contribution <- tibble::lst(scenario1_E_B_contribution_2yr_conv,
                                scenario1_E_B_contribution_2yr_low,
                                scenario1_E_B_contribution_3yr_conv,
                                scenario1_E_B_contribution_3yr_low,
                                scenario1_E_B_contribution_4yr_conv,
                                scenario1_E_B_contribution_4yr_low )


scenario1_E_B_contribution_unlist <- unlist(scenario1_E_B_contribution, recursive = FALSE)

#View(E_B_contribution  )
# Keep non-zeros only 
matrix_trim <- function(x) {
      m1 <- x == 0
      x[!(rowSums(m1)== ncol(m1)), 
      !(colSums(m1) == nrow(m1)),drop = FALSE]
}

#scenario1_E_B_contribution_trimmed  <- rapply(scenario1_E_B_contribution,\(x) matrix_trim(x), how='list')


#rapply(scenario1_E_B_contribution_trimmed ,\(x) round(x,3),how='list')

```



```{r scenario1-E-B-spring-till, echo=FALSE}
scenario1_E_B_spring_tillage <-  scenario1_E_B_contribution_unlist[str_detect(names(scenario1_E_B_contribution_unlist), "spring")]

# View( scenario1_E_B_spring_tillage )

# relevant number: the first row from column 3 to 8
# The non-zeros in (1,1) and (1,2) and row 2 are remnants from how the 
scenario1_E_B_spring_tillage_trimmed <-  rapply(scenario1_E_B_spring_tillage,\(x) matrix_trim(x), how='list') #View( E_B_spring_tillage_trimmed )

#convert matrix to vector, the vector was binded by column (column 2 after column 1) 
scenario1_E_B_spring_tillage_vector <- rapply(scenario1_E_B_spring_tillage_trimmed,\(x) c(x), how='list') 
# View(E_B_spring_tillage_vector )

## Separate spring tillage E_B by corn weed management to manage the rowname string 
scenario1_E_B_spring_tillage_conv <- scenario1_E_B_spring_tillage_vector[str_detect(names(scenario1_E_B_spring_tillage_vector), "conv")]

scenario1_E_B_spring_tillage_low <- scenario1_E_B_spring_tillage_vector[str_detect(names(scenario1_E_B_spring_tillage_vector), "low")]

scenario1_E_B_spring_tillage_conv_unlist <- scenario1_E_B_spring_tillage_conv %>% 
  unlist(., recursive = FALSE) %>% 
  data.frame(fix.empty.names = TRUE) %>% 
  rename(E_B_ij = ".") %>%
  tibble::rownames_to_column() %>%
  mutate(Crop_ID = substr(rowname, 37, 38),
         Corn_weed_management = substr(rowname, 40, 43),
         group = substring(rowname, 49),
         Crop = substr(rowname, 37, 37),
         Rotation = substr(rowname, 28, 30)) %>%
  mutate(element_ij = ifelse(endsWith(group, "1"), "st1_1",
                             ifelse(endsWith(group, "2"), "st2_1",
                                    ifelse(endsWith(group, "3"), "st1_2", "st2_2"))))
  
# View( scenario1_E_B_spring_tillage_conv_unlist )
# st_ij: spring tillage induced seed movement from strata i (top) to j (bottom)
scenario1_E_B_spring_tillage_low_unlist <- scenario1_E_B_spring_tillage_low %>% 
  unlist(., recursive = FALSE) %>% 
  data.frame(fix.empty.names = TRUE) %>% 
  rename(E_B_ij = ".") %>%
  tibble::rownames_to_column() %>%
  mutate(Crop_ID = substr(rowname, 36, 37),
         Corn_weed_management = substr(rowname, 39, 41),
         group = substring(rowname, 48),
         Crop = substr(rowname, 36, 36),
         Rotation = substr(rowname, 28, 30)) %>%
  mutate(element_ij = ifelse(endsWith(group, "1"), "st1_1",
                             ifelse(endsWith(group, "2"), "st2_1",
                                    ifelse(endsWith(group, "3"), "st1_2", "st2_2"))))


# View( scenario1_E_B_spring_tillage_low_unlist)

# recombine conv and low 
scenario1_E_B_spring_tillage_recombine <- rbind(scenario1_E_B_spring_tillage_conv_unlist, scenario1_E_B_spring_tillage_low_unlist)
#View(scenario1_E_B_spring_tillage_recombine)


scenario1_E_B_spring_tillage_recombine_wide <- scenario1_E_B_spring_tillage_recombine %>%
  select(!c(rowname, group)) %>% 
  pivot_wider(names_from = element_ij, values_from = E_B_ij) %>%
  mutate(Scenario = 1) %>%
  select(Scenario, Rotation, Crop, Crop_ID, Corn_weed_management, st1_1:st2_2) %>%
  mutate(Order = ifelse(Crop == "C", 1,
                        ifelse(Crop == "S", 2,
                               ifelse(Crop == "O", 3, 4))))%>%
  arrange(Rotation, Order, Corn_weed_management) %>%
  select(!c(Order, Crop)) %>% 
   mutate_at(5:8, round, 2)

#View( scenario1_E_B_spring_tillage_recombine_wide )

```

```{r scenario1-E-B-emerge, echo=FALSE}
scenario1_E_B_emerge <-  scenario1_E_B_contribution_unlist[str_detect(names(scenario1_E_B_contribution_unlist), "emerge")]

# View(scenario1_E_B_emerge)

# relevant number: the first row from column 3 to 8; in reality, bottom seeds do not germinate
scenario1_E_B_emerge_trimmed <-  rapply(scenario1_E_B_emerge,\(x) x[1,], how='list')
# View( E_B_emerge_trimmed )


## Separate spring tillage E_B by corn weed management to manage the rowname string 
scenario1_E_B_emerge_conv <- scenario1_E_B_emerge_trimmed[str_detect(names(scenario1_E_B_emerge_trimmed), "conv")]

scenario1_E_B_emerge_low <- scenario1_E_B_emerge_trimmed[str_detect(names(scenario1_E_B_emerge_trimmed ), "low")]

scenario1_E_B_emerge_conv_unlist <- scenario1_E_B_emerge_conv %>% 
  unlist(., recursive = FALSE) %>% 
  data.frame(fix.empty.names = TRUE) %>% 
  rename(E_B_ij = ".") %>%
  tibble::rownames_to_column() %>%
  mutate(Crop_ID = substr(rowname, 37, 38),
         Corn_weed_management = substr(rowname, 32, 35),
         group = substring(rowname, 69),
         Crop = substr(rowname, 37, 37),
         Rotation = substr(rowname, 28,30))
  
 View( scenario1_E_B_emerge_conv_unlist)

scenario1_E_B_emerge_low_unlist <- scenario1_E_B_emerge_low %>% 
  unlist(., recursive = FALSE) %>% 
  data.frame(fix.empty.names = TRUE) %>% 
  rename(E_B_ij = ".") %>%
  tibble::rownames_to_column() %>%
  mutate(Crop_ID = substr(rowname, 36, 37),
         Corn_weed_management = substr(rowname, 32, 34),
         group = substring(rowname, 67),
         Crop = substr(rowname, 37, 37),
         Rotation = substr(rowname, 28, 30))
# View( scenario1_E_B_emerge_low_unlist)

# recombine conv and low 
scenario1_E_B_emerge_recombine <- rbind(scenario1_E_B_emerge_conv_unlist, scenario1_E_B_emerge_low_unlist)
#View(scenario1_E_B_emerge_recombine)


scenario1_E_B_emerge_recombine_wide <- scenario1_E_B_emerge_recombine %>%
  select(!rowname) %>% 
  pivot_wider(names_from = group, values_from = E_B_ij) %>%
  mutate(Scenario = 1)  %>%
  select(Scenario, Rotation, Crop, Crop_ID, Corn_weed_management, seed_top:plant_cohort_6) %>%
  mutate(Order = ifelse(Crop == "C", 1,
                        ifelse(Crop == "S", 2,
                               ifelse(Crop == "O", 3, 4))))%>%
  arrange(Rotation, Order, Corn_weed_management) %>%
  select(!c(Order, Crop, seed_bottom)) %>% #keep the relevant columns only 
   mutate_at(5:11, round, 2) %>%
  rename(`1-sum(e)` = seed_top,
        e_1= plant_cohort_1,
        e_2 = plant_cohort_2,
        e_3 = plant_cohort_3,
        e_4 = plant_cohort_4,
        e_5 = plant_cohort_5,
        e_6 = plant_cohort_6)

#View(scenario1_E_B_emerge_recombine_wide) 
```

```{r scenario1-E-B-summer, echo=FALSE}
scenario1_E_B_summer <-  scenario1_E_B_contribution_unlist[str_detect(names(scenario1_E_B_contribution_unlist), "summer")]

# relevant numbers: the diagonal 
# off diagonal elements  were remnants
scenario1_E_B_summer_diag <-  rapply(scenario1_E_B_summer,\(x) diag(x), how='list')
# View( E_B_summer_diag)

## Separate seedling survival E_B by corn weed management to manage the rowname string 
scenario1_E_B_summer_conv <- scenario1_E_B_summer_diag[str_detect(names(scenario1_E_B_summer_diag), "conv")]

scenario1_E_B_summer_low <- scenario1_E_B_summer_diag[str_detect(names(scenario1_E_B_summer_diag), "low")]


scenario1_E_B_summer_conv_unlist <- scenario1_E_B_summer_conv %>% 
  unlist(., recursive = FALSE) %>% 
  data.frame(fix.empty.names = TRUE) %>% 
  rename(E_B_ij = ".") %>%
  tibble::rownames_to_column() %>%
  mutate(Crop_ID = substr(rowname, 37, 38),
         Corn_weed_management = substr(rowname, 32, 35),
         group = substring(rowname, 75),
         Crop = substr(rowname, 37, 37),
         Rotation = substr(rowname, 28, 30)) 

#  View(scenario1_E_B_summer_conv_unlist)  

scenario1_E_B_summer_low_unlist <- scenario1_E_B_summer_low %>% 
  unlist(., recursive = FALSE) %>% 
  data.frame(fix.empty.names = TRUE) %>% 
  rename(E_B_ij = ".") %>%
  tibble::rownames_to_column() %>%
 mutate(Crop_ID = substr(rowname, 36, 37),
         Corn_weed_management = substr(rowname, 32, 34),
         group = substring(rowname, 73),
         Crop = substr(rowname, 36, 36),
         Rotation = substr(rowname, 28, 30)) 

# View( scenario1_E_B_summer_low_unlist)

# recombine summer plant survival conv and low 
scenario1_E_B_summer_recombine <- rbind(scenario1_E_B_summer_conv_unlist, scenario1_E_B_summer_low_unlist )

scenario1_E_B_summer_recombine_wide <- scenario1_E_B_summer_recombine %>%
  select(!rowname) %>% 
  pivot_wider(names_from = group, values_from = E_B_ij) %>%
  mutate(Scenario = 1) %>%
  select(Scenario,  Rotation, Crop, Crop_ID, Corn_weed_management, seed_top:plant_cohort_6) %>%
  mutate(Order = ifelse(Crop == "C", 1,
                        ifelse(Crop == "S", 2,
                               ifelse(Crop == "O", 3, 4)))) %>%
  arrange(Rotation, Order, Corn_weed_management) %>%
  select(!c(Order, Crop)) %>% 
  mutate_at(5:12, round, 2) %>%
  rename(sss_1 = seed_top,
         sss_2 = seed_bottom,
        sps_1= plant_cohort_1,
        sps_2 = plant_cohort_2,
        sps_3 = plant_cohort_3,
        sps_4 = plant_cohort_4,
        sps_5 = plant_cohort_5,
        sps_6 = plant_cohort_6)

#View(scenario1_E_B_summer_recombine_wide) 
```


```{r scenario1-E-B-fecund, echo=FALSE}
scenario1_E_B_fecund <-  scenario1_E_B_contribution_unlist[str_detect(names(scenario1_E_B_contribution_unlist), "fecund")]

# relevant number: the first row from column 3 to 8
# The non-zeros in (1,1) and (1,2) and row 2 are remnants from how the 
scenario1_E_B_fecund_trimmed <-  rapply(scenario1_E_B_fecund,\(x) x[1,], how='list')


## Separate fecundity E_B by corn weed management to manage the rowname string 
scenario1_E_B_fecund_conv <- scenario1_E_B_fecund_trimmed[str_detect(names(scenario1_E_B_fecund_trimmed), "conv")]

scenario1_E_B_fecund_low <- scenario1_E_B_fecund_trimmed[str_detect(names(scenario1_E_B_fecund_trimmed), "low")]

scenario1_E_B_fecund_conv_unlist <- scenario1_E_B_fecund_conv %>% 
  unlist(., recursive = FALSE) %>% 
  data.frame(fix.empty.names = TRUE) %>% 
  rename(E_B_ij = ".") %>%
  tibble::rownames_to_column() %>%
  mutate(Crop_ID = substr(rowname, 37, 38),
         Corn_weed_management = substr(rowname, 32, 35),
         group = substring(rowname, 74),
         Crop = substr(rowname, 37, 37),
         Rotation = substr(rowname, 28, 30)) %>%
  filter(group != c("seed_top", "seed_bottom")) # keep the relevant numbers only 

# View(scenario1_E_B_fecund_conv_unlist)
scenario1_E_B_fecund_low_unlist <- scenario1_E_B_fecund_low %>% 
  unlist(., recursive = FALSE) %>% 
  data.frame(fix.empty.names = TRUE) %>% 
  rename(E_B_ij = ".") %>%
  tibble::rownames_to_column() %>%
  mutate(Crop_ID = substr(rowname, 36, 37),
         Corn_weed_management = substr(rowname, 32, 34),
         group = substring(rowname, 72),
         Crop = substr(rowname, 36, 36),
         Rotation = substr(rowname, 28, 30)) %>%
  filter(group != c("seed_top", "seed_bottom")) # keep the relevant numbers only 

# recombine conv and low 
scenario1_E_B_fecund_recombine <- rbind(scenario1_E_B_fecund_conv_unlist, scenario1_E_B_fecund_low_unlist)

scenario1_E_B_fecund_recombine_wide <- scenario1_E_B_fecund_recombine %>%
  select(!rowname) %>% 
  pivot_wider(names_from = group, values_from = E_B_ij) %>%
  mutate(Scenario = 1) %>%
  select(Scenario, Rotation, Crop, Crop_ID, Corn_weed_management, plant_cohort_1:plant_cohort_6) %>%
  mutate(Order = ifelse(Crop == "C", 1,
                        ifelse(Crop == "S", 2,
                               ifelse(Crop == "O", 3, 4)))) %>%
  arrange(Rotation, Order, Corn_weed_management) %>%
  select(!c(Order, Crop))  %>%
   mutate_at(5:10, round, 2)  %>%
  rename(f_1= plant_cohort_1,
        f_2 = plant_cohort_2,
        f_3 = plant_cohort_3,
        f_4 = plant_cohort_4,
        f_5 = plant_cohort_5,
        f_6 = plant_cohort_6)

#View(scenario1_E_B_fecund_recombine_wide)
```


```{r scenario1-E-B-postharvest-till, echo=FALSE}
scenario1_E_B_postharvest_tillage <-  scenario1_E_B_contribution_unlist[str_detect(names(scenario1_E_B_contribution_unlist), "harvest")]

# View( scenario1_E_B_postharvest_tillage )

# relevant number: the first row from column 3 to 8
# The non-zeros in (1,1) and (1,2) and row 2 are remnants from how the 
scenario1_E_B_postharvest_tillage_trimmed <-  rapply(scenario1_E_B_postharvest_tillage,\(x) matrix_trim(x), how='list')
# View( scenario1_E_B_postharvest_tillage_trimmed )

#convert matrix to vector, the vector was binded by column (column 2 after column 1) 
scenario1_E_B_postharvest_tillage_vector <- rapply(scenario1_E_B_postharvest_tillage_trimmed,\(x) c(x), how='list') 
# View(scenario1_E_B_postharvest_tillage_vector )

## Separate spring tillage E_B by corn weed management to manage the rowname string 
scenario1_E_B_postharvest_tillage_conv <- scenario1_E_B_postharvest_tillage_vector[str_detect(names(scenario1_E_B_postharvest_tillage_vector), "conv")]

scenario1_E_B_postharvest_tillage_low <- scenario1_E_B_postharvest_tillage_vector[str_detect(names(scenario1_E_B_postharvest_tillage_vector), "low")]

#View( scenario1_E_B_postharvest_tillage_low )
scenario1_E_B_postharvest_tillage_conv_unlist <- scenario1_E_B_postharvest_tillage_conv %>% 
  unlist(., recursive = FALSE) %>% 
  data.frame(fix.empty.names = TRUE) %>% 
  rename(E_B_ij = ".") %>%
  tibble::rownames_to_column() %>%
  mutate(Crop_ID = substr(rowname, 37, 38),
         Corn_weed_management = substr(rowname, 32, 35),
         group = substring(rowname, 49),
         Crop = substr(rowname, 37, 37),
         Rotation = substr(rowname, 28, 30)) %>%
  mutate(element_ij = ifelse(endsWith(group, "1"), "ft1_1",
                             ifelse(endsWith(group, "2"), "ft2_1",
                                    ifelse(endsWith(group, "3"), "ft1_2", "ft2_2"))))
  
# View( scenario1_E_B_postharvest_tillage_conv_unlist)
scenario1_E_B_postharvest_tillage_low_unlist <- scenario1_E_B_postharvest_tillage_low %>% 
  unlist(., recursive = FALSE) %>% 
  data.frame(fix.empty.names = TRUE) %>% 
  rename(E_B_ij = ".") %>%
  tibble::rownames_to_column() %>%
   mutate(Crop_ID = substr(rowname, 36, 37),
         Corn_weed_management = substr(rowname, 32, 34),
         group = substring(rowname, 47),
         Crop = substr(rowname, 36, 36),
         Rotation = substr(rowname, 28, 30)) %>%
  mutate(element_ij = ifelse(endsWith(group, "1"), "ft1_1",
                             ifelse(endsWith(group, "2"), "ft2_1",
                                    ifelse(endsWith(group, "3"), "ft1_2", "ft2_2"))))

# View( scenario1_E_B_postharvest_tillage_low_unlist)

# recombine conv and low 
scenario1_E_B_postharvest_tillage_recombine <- rbind(scenario1_E_B_postharvest_tillage_conv_unlist, scenario1_E_B_postharvest_tillage_low_unlist)
#View(scenario1_E_B_postharvest_tillage_recombine)


scenario1_E_B_postharvest_tillage_recombine_wide <- scenario1_E_B_postharvest_tillage_recombine %>%
  select(!c(rowname, group)) %>% 
  pivot_wider(names_from = element_ij, values_from = E_B_ij) %>%
  mutate(Parameter = "post-harvest tillage", 
         Scenario = 1) %>%
  select(Scenario, Rotation, Crop, Crop_ID, Corn_weed_management, ft1_1:ft2_2) %>%
  mutate(Order = ifelse(Crop == "C", 1,
                        ifelse(Crop == "S", 2,
                               ifelse(Crop == "O", 3, 4))))%>%
  arrange(Rotation, Order, Corn_weed_management) %>%
  select(!c(Order, Crop)) %>%
   mutate_at(5:8, round, 2)

# View(scenario1_E_B_postharvest_tillage_recombine_wide)
```


```{r scenario1-E-B-overwinter, echo=FALSE}
scenario1_E_B_overwinter <-  scenario1_E_B_contribution_unlist[str_detect(names(scenario1_E_B_contribution_unlist), "overwinter")]

#View( scenario1_scenario1_E_B_overwinter )

# relevant number: the first row from column 3 to 8
# The non-zeros in (1,1) and (1,2) and row 2 are remnants from how the 
scenario1_E_B_overwinter_trimmed <-  rapply(scenario1_E_B_overwinter,\(x) matrix_trim(x), how='list')
#View( scenario1_E_B_overwinter_trimmed )

#keep the diagonal only 
scenario1_E_B_overwinter_vector <- rapply(scenario1_E_B_overwinter_trimmed,\(x) diag(x), how='list') 
#View(scenario1_E_B_overwinter_vector )

## Separate spring tillage E_B by corn weed management to manage the rowname string 
scenario1_E_B_overwinter_conv <- scenario1_E_B_overwinter_vector[str_detect(names(scenario1_E_B_overwinter_vector), "conv")]

scenario1_E_B_overwinter_low <- scenario1_E_B_overwinter_vector[str_detect(names(scenario1_E_B_overwinter_vector), "low")]

scenario1_E_B_overwinter_conv_unlist <- scenario1_E_B_overwinter_conv %>% 
  unlist(., recursive = FALSE) %>% 
  data.frame(fix.empty.names = TRUE) %>% 
  rename(E_B_ij = ".") %>%
  tibble::rownames_to_column() %>%
  mutate(Crop_ID = substr(rowname, 37, 38),
         Corn_weed_management = substr(rowname, 32, 35),
         group = substring(rowname, 70),
         Crop = substr(rowname, 37, 37),
         Rotation = substr(rowname, 28, 30)) 
  
# View( scenario1_E_B_overwinter_conv_unlist)
scenario1_E_B_overwinter_low_unlist <- scenario1_E_B_overwinter_low %>% 
  unlist(., recursive = FALSE) %>% 
  data.frame(fix.empty.names = TRUE) %>% 
  rename(E_B_ij = ".") %>%
  tibble::rownames_to_column() %>%
   mutate(Crop_ID = substr(rowname, 36, 37),
         Corn_weed_management = substr(rowname, 32, 34),
         group = substring(rowname, 68),
         Crop = substr(rowname, 36, 36),
         Rotation = substr(rowname, 28, 30)) 

#View( scenario1_E_B_overwinter_low_unlist)

# recombine conv and low 
scenario1_E_B_overwinter_recombine <- rbind(scenario1_E_B_overwinter_conv_unlist, scenario1_E_B_overwinter_low_unlist)
#View(scenario1_E_B_overwinter_recombine)

#so stand for survival overwinter
scenario1_E_B_overwinter_recombine_wide <- scenario1_E_B_overwinter_recombine %>%
  select(!rowname) %>% 
  pivot_wider(names_from = group, values_from = E_B_ij) %>%
  mutate(Scenario = 1) %>%
  select(Scenario, Rotation, Crop, Crop_ID, Corn_weed_management, seed_top, seed_bottom) %>%
  mutate(Order = ifelse(Crop == "C", 1,
                        ifelse(Crop == "S", 2,
                               ifelse(Crop == "O", 3, 4))))%>%
  arrange(Rotation, Order, Corn_weed_management) %>%
  select(!c(Order, Crop)) %>%
   mutate_at(5:6, round, 2)  %>%
  rename(wss_1 = seed_top,
         wss_2 = seed_bottom)

# View(scenario1_E_B_overwinter_recombine_wide)
```

```{r scenario1-E-B-by-rot, echo=FALSE, warning=FALSE, message=FALSE}
## Recombine all the E-B tables
scenario1_E_B_recombine_wide <- plyr::join_all(list(scenario1_E_B_spring_tillage_recombine_wide,
            scenario1_E_B_emerge_recombine_wide,
            scenario1_E_B_summer_recombine_wide,
            scenario1_E_B_fecund_recombine_wide,
            scenario1_E_B_postharvest_tillage_recombine_wide,
            scenario1_E_B_overwinter_recombine_wide), by = c("Scenario", "Rotation", "Crop_ID", "Corn_weed_management"), type='left')  %>% select(!c(Rotation,Scenario)) 

## View( scenario1_E_B_recombine_wide )

# remove all-zero columns: https://stackoverflow.com/questions/21530168/remove-columns-with-zero-values-from-a-dataframe
scenario1_E_B_recombine_wide_zero_col_removed <-  scenario1_E_B_recombine_wide[, colSums(scenario1_E_B_recombine_wide != 0) > 0]

## Use the non-zero only dataframe to make a flextable
scenario1_E_B_recombine_wide_zero_col_removed  %>% 
  flextable::flextable()  -> scenario1_E_B_plain


for(i in seq_len(nrow(scenario1_E_B_recombine_wide_zero_col_removed )))
{
  scenario1_E_B_plain %<>% flextable::bold(i, which.max(scenario1_E_B_recombine_wide_zero_col_removed[i,]))
}


```

```{r scenario1-E-B-by-rot-tab, echo = FALSE, results='asis'}
#https://stackoverflow.com/questions/62148912/sharing-of-footnote-between-different-part-of-tables-using-flextable
# special character list: http://www.ephotocaption.com/a/106/106.html
scenario1_E_B_plain %>%
  fontsize(size = 6, part = "all") %>%
  set_caption("Scenario1 - Elasticity of population growth rate to lower level demographic parameters")  %>%
  set_table_properties(layout = "autofit") %>%
  footnote(i = 1, j = 3:6,
           value = as_paragraph(c("st_ij: the probability of seed movement from soil stratum i to j by pre-planting tillage")),
           part = "header",
           ref_symbols = "*")  %>%
    footnote(i = 1, j = 7,
           value = as_paragraph(c("1-sum(e): the probability of non-emerging seeds in the top (0-2 cm) soil stratum")),
           part = "header",
           ref_symbols = "\U00A7")  %>%
#  footnote(i = 1, j = 9:14,
#           value = as_paragraph(c("e_1 through e_6: the probability of seeds in the 0-2 cm soil stratum emerging to seedling cohorts 1 though 6")),
#           part = "header",
#           ref_symbols = "\U00B6" )  %>%
      footnote(i = 1, j = 8:9,
           value = as_paragraph(c("sss_1 and sss_2: the summer survival probabilities of the seeds in the top (0-2 cm) and bottom (2-20 cm) soil strata")),
           part = "header",
           ref_symbols =  "\U2020") %>%
#      footnote(i = 1, j = 17:22,
#           value = as_paragraph(c( "sps_1 through sps_6: the probabilities that seedling cohorts 1 through 6 reach maturity")),
#           part = "header",
#           ref_symbols = "\U2021")  %>%
      footnote(i = 1, j = 10:15,
           value = as_paragraph(c( "f_1 though f_6: the individual fecundity of mature plants in cohorts 1 through 6")),
           part = "header",
           ref_symbols = "\U204B")  %>%
      footnote(i = 1, j = 16:19,
           value = as_paragraph(c( "ft_ij: the probability of seed movement from soil stratum i to j by post-harvest tillage")),
           part = "header",
           ref_symbols = "\U2307")  %>%
      footnote(i = 1, j = 20:21,
           value = as_paragraph(c("wss_1 and wss_2: the overwinter survival probabilities of seeds in the top (0-2 cm) and bottom (2-20 cm) soil strata")),
           part = "header",
           ref_symbols = "\U2351")  %>%
  footnote(i = NULL, j = NULL,
           value = as_paragraph("All-zero columns are excluded. In Crop_ID: C2 - corn in the 2 year rotation, S2 - soybean in the 2-year rotation, C3 - corn in the 3-year rotation, S3 - soybean in the 3-year rotation, O3 - oat intercroped with red clover in the 3-year rotation, C4 - corn in the 4-year rotation, S4 - soybean in the 4-year rotation, O4 - oat intercropped with alfalfa in the 4-year rotation, and A4 - alfalfa in the 4-year rotation."), 
           part = "footer", 
           ref_symbols = " ") # need " ", otherwise flextable will put "1" as the ref_symbol
# multiple Greek letters as headers 
# which zeros were due to rounding and which negligible 
```

